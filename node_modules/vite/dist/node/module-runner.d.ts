import { ModuleNamespace, ViteHotContext } from '../../types/hot.js';
import { Update, HotPayload } from '../../types/hotPayload.js';
import { InferCustomEventPayload } from '../../types/customEvent.js';

interface SourceMapLike {
    version: number;
    mappings?: string;
    names?: string[];
    sources?: string[];
    sourcesContent?: string[];
}
declare class DecodedMap {
    map: SourceMapLike;
    _encoded: string;
    _decoded: undefined | number[][][];
    _decodedMemo: Stats;
    url: string;
    version: number;
    names: string[];
    resolvedSources: string[];
    constructor(map: SourceMapLike, from: string);
}
interface Stats {
    lastKey: number;
    lastNeedle: number;
    lastIndex: number;
}

type CustomListenersMap = Map<string, ((data: any) => void)[]>;
interface HotModule {
    id: string;
    callbacks: HotCallback[];
}
interface HotCallback {
    deps: string[];
    fn: (modules: Array<ModuleNamespace | undefined>) => void;
}
interface HMRLogger {
    error(msg: string | Error): void;
    debug(...msg: unknown[]): void;
}
interface HMRConnection {
    /**
     * Checked before sending messages to the client.
     */
    isReady(): boolean;
    /**
     * Send message to the client.
     */
    send(messages: string): void;
}
declare class HMRMessenger {
    private connection;
    constructor(connection: HMRConnection);
    private queue;
    send(message: string): void;
    flush(): void;
}
declare class HMRClient {
    logger: HMRLogger;
    private importUpdatedModule;
    hotModulesMap: Map<string, HotModule>;
    disposeMap: Map<string, (data: any) => void | Promise<void>>;
    pruneMap: Map<string, (data: any) => void | Promise<void>>;
    dataMap: Map<string, any>;
    customListenersMap: CustomListenersMap;
    ctxToListenersMap: Map<string, CustomListenersMap>;
    messenger: HMRMessenger;
    constructor(logger: HMRLogger, connection: HMRConnection, importUpdatedModule: (update: Update) => Promise<ModuleNamespace>);
    notifyListeners<T extends string>(event: T, data: InferCustomEventPayload<T>): Promise<void>;
    clear(): void;
    prunePaths(paths: string[]): Promise<void>;
    protected warnFailedUpdate(err: Error, path: string | string[]): void;
    private updateQueue;
    private pendingUpdateQueue;
    /**
     * buffer multiple hot updates triggered by the same src change
     * so that they are invoked in the same order they were sent.
     * (otherwise the order may be inconsistent because of the http request round trip)
     */
    queueUpdate(payload: Update): Promise<void>;
    private fetchUpdate;
}

interface DefineImportMetadata {
    /**
     * Imported names before being transformed to `ssrImportKey`
     *
     * import foo, { bar as baz, qux } from 'hello'
     * => ['default', 'bar', 'qux']
     *
     * import * as namespace from 'world
     * => undefined
     */
    importedNames?: string[];
}
interface SSRImportBaseMetadata extends DefineImportMetadata {
    isDynamicImport?: boolean;
}

declare const ssrModuleExportsKey = "__vite_ssr_exports__";
declare const ssrImportKey = "__vite_ssr_import__";
declare const ssrDynamicImportKey = "__vite_ssr_dynamic_import__";
declare const ssrExportAllKey = "__vite_ssr_exportAll__";
declare const ssrImportMetaKey = "__vite_ssr_import_meta__";

interface ModuleRunnerDebugger {
    (formatter: unknown, ...args: unknown[]): void;
}
declare class ModuleRunner {
    options: ModuleRunnerOptions;
    evaluator: ModuleEvaluator;
    private debug?;
    /**
     * Holds the cache of modules
     * Keys of the map are ids
     */
    moduleCache: ModuleCacheMap;
    hmrClient?: HMRClient;
    private readonly urlToIdMap;
    private readonly fileToIdMap;
    private readonly envProxy;
    private readonly transport;
    private readonly resetSourceMapSupport?;
    private destroyed;
    constructor(options: ModuleRunnerOptions, evaluator: ModuleEvaluator, debug?: ModuleRunnerDebugger | undefined);
    /**
     * URL to execute. Accepts file path, server path or id relative to the root.
     */
    import<T = any>(url: string): Promise<T>;
    /**
     * Clear all caches including HMR listeners.
     */
    clearCache(): void;
    /**
     * Clears all caches, removes all HMR listeners, and resets source map support.
     * This method doesn't stop the HMR connection.
     */
    destroy(): Promise<void>;
    /**
     * Returns `true` if the runtime has been destroyed by calling `destroy()` method.
     */
    isDestroyed(): boolean;
    private normalizeEntryUrl;
    private processImport;
    private cachedRequest;
    private cachedModule;
    protected directRequest(id: string, mod: ModuleCache, _callstack: string[]): Promise<any>;
}

interface RetrieveFileHandler {
    (path: string): string | null | undefined | false;
}
interface RetrieveSourceMapHandler {
    (path: string): null | {
        url: string;
        map: any;
    };
}
interface InterceptorOptions {
    retrieveFile?: RetrieveFileHandler;
    retrieveSourceMap?: RetrieveSourceMapHandler;
}

interface RunnerTransport {
    fetchModule: FetchFunction;
}
declare class RemoteRunnerTransport implements RunnerTransport {
    private readonly options;
    private rpcPromises;
    constructor(options: {
        send: (data: any) => void;
        onMessage: (handler: (data: any) => void) => void;
        timeout?: number;
    });
    private resolve;
    fetchModule(id: string, importer?: string): Promise<FetchResult>;
}

interface ModuleRunnerHMRConnection extends HMRConnection {
    /**
     * Configure how HMR is handled when this connection triggers an update.
     * This method expects that connection will start listening for HMR updates and call this callback when it's received.
     */
    onUpdate(callback: (payload: HotPayload) => void): void;
}
interface ModuleRunnerImportMeta extends ImportMeta {
    url: string;
    env: ImportMetaEnv;
    hot?: ViteHotContext;
    [key: string]: any;
}
interface ModuleRunnerContext {
    [ssrModuleExportsKey]: Record<string, any>;
    [ssrImportKey]: (id: string, metadata?: DefineImportMetadata) => Promise<any>;
    [ssrDynamicImportKey]: (id: string, options?: ImportCallOptions) => Promise<any>;
    [ssrExportAllKey]: (obj: any) => void;
    [ssrImportMetaKey]: ModuleRunnerImportMeta;
}
interface ModuleEvaluator {
    /**
     * Run code that was transformed by Vite.
     * @param context Function context
     * @param code Transformed code
     * @param id ID that was used to fetch the module
     */
    runInlinedModule(context: ModuleRunnerContext, code: string, id: string): Promise<any>;
    /**
     * Run externalized module.
     * @param file File URL to the external module
     */
    runExternalModule(file: string): Promise<any>;
}
interface ModuleCache {
    promise?: Promise<any>;
    exports?: any;
    evaluated?: boolean;
    map?: DecodedMap;
    meta?: ResolvedResult;
    /**
     * Module ids that imports this module
     */
    importers?: Set<string>;
    imports?: Set<string>;
}
type FetchResult = CachedFetchResult | ExternalFetchResult | ViteFetchResult;
interface CachedFetchResult {
    /**
     * If module cached in the runner, we can just confirm
     * it wasn't invalidated on the server side.
     */
    cache: true;
}
interface ExternalFetchResult {
    /**
     * The path to the externalized module starting with file://,
     * by default this will be imported via a dynamic "import"
     * instead of being transformed by vite and loaded with vite runner
     */
    externalize: string;
    /**
     * Type of the module. Will be used to determine if import statement is correct.
     * For example, if Vite needs to throw an error if variable is not actually exported
     */
    type?: 'module' | 'commonjs' | 'builtin' | 'network';
}
interface ViteFetchResult {
    /**
     * Code that will be evaluated by vite runner
     * by default this will be wrapped in an async function
     */
    code: string;
    /**
     * File path of the module on disk.
     * This will be resolved as import.meta.url/filename
     * Will be equal to `null` for virtual modules
     */
    file: string | null;
    /**
     * Invalidate module on the client side.
     */
    invalidate: boolean;
}
type ResolvedResult = (ExternalFetchResult | ViteFetchResult) & {
    id: string;
};
type FetchFunction = (id: string, importer?: string, options?: FetchFunctionOptions) => Promise<FetchResult>;
interface FetchFunctionOptions {
    cached?: boolean;
}
interface ModuleRunnerHmr {
    /**
     * Configure how HMR communicates between the client and the server.
     */
    connection: ModuleRunnerHMRConnection;
    /**
     * Configure HMR logger.
     */
    logger?: false | HMRLogger;
}
interface ModuleRunnerOptions {
    /**
     * Root of the project
     */
    root: string;
    /**
     * A set of methods to communicate with the server.
     */
    transport: RunnerTransport;
    /**
     * Configure how source maps are resolved. Prefers `node` if `process.setSourceMapsEnabled` is available.
     * Otherwise it will use `prepareStackTrace` by default which overrides `Error.prepareStackTrace` method.
     * You can provide an object to configure how file contents and source maps are resolved for files that were not processed by Vite.
     */
    sourcemapInterceptor?: false | 'node' | 'prepareStackTrace' | InterceptorOptions;
    /**
     * Disable HMR or configure HMR options.
     */
    hmr?: false | ModuleRunnerHmr;
    /**
     * Custom module cache. If not provided, creates a separate module cache for each ModuleRunner instance.
     */
    moduleCache?: ModuleCacheMap;
}
interface ImportMetaEnv {
    [key: string]: any;
    BASE_URL: string;
    MODE: string;
    DEV: boolean;
    PROD: boolean;
    SSR: boolean;
}

declare class ModuleCacheMap extends Map<string, ModuleCache> {
    private root;
    constructor(root: string, entries?: [string, ModuleCache][]);
    normalize(fsPath: string): string;
    /**
     * Assign partial data to the map
     */
    update(fsPath: string, mod: ModuleCache): this;
    setByModuleId(modulePath: string, mod: ModuleCache): this;
    set(fsPath: string, mod: ModuleCache): this;
    getByModuleId(modulePath: string): ModuleCache;
    get(fsPath: string): ModuleCache;
    deleteByModuleId(modulePath: string): boolean;
    delete(fsPath: string): boolean;
    invalidateUrl(id: string): void;
    invalidateModule(module: ModuleCache): void;
    /**
     * Invalidate modules that dependent on the given modules, up to the main entry
     */
    invalidateDepTree(ids: string[] | Set<string>, invalidated?: Set<string>): Set<string>;
    /**
     * Invalidate dependency modules of the given modules, down to the bottom-level dependencies
     */
    invalidateSubDepTree(ids: string[] | Set<string>, invalidated?: Set<string>): Set<string>;
    getSourceMap(moduleId: string): null | DecodedMap;
}

declare class ESModulesEvaluator implements ModuleEvaluator {
    runInlinedModule(context: ModuleRunnerContext, code: string): Promise<any>;
    runExternalModule(filepath: string): Promise<any>;
}

export { ESModulesEvaluator, type FetchFunction, type FetchFunctionOptions, type FetchResult, type HMRConnection, type HMRLogger, type ModuleCache, ModuleCacheMap, type ModuleEvaluator, ModuleRunner, type ModuleRunnerContext, type ModuleRunnerHMRConnection, type ModuleRunnerHmr, type ModuleRunnerImportMeta, type ModuleRunnerOptions, RemoteRunnerTransport, type ResolvedResult, type RunnerTransport, type SSRImportBaseMetadata as SSRImportMetadata, ssrDynamicImportKey, ssrExportAllKey, ssrImportKey, ssrImportMetaKey, ssrModuleExportsKey };
