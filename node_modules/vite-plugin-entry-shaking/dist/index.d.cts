import { Logger as Logger$1, LogOptions, ResolvedConfig, ResolveFn, PluginOption } from 'vite';
import { Options } from 'fast-glob';
import EventEmitter from 'events';

/** Vite plugin options. */
interface PluginOptions {
    /** List of the entry points. */
    targets: PluginTargets;
    /** Specifies which file extensions you want this plugin to process. */
    extensions?: string[];
    /** Specifies RegExp/string whose matched paths must be ignored by the plugin. */
    ignorePatterns?: any[];
    /** How deep should this plugin run static analysis when encountering wildcards? */
    maxWildcardDepth?: number | undefined;
    /** Diagnostics configuration. */
    diagnostics?: boolean | DiagnosticsConfig;
    /** Defines whether debug mode should be enabled. */
    debug?: boolean;
}
/** Diagnostics configuration. */
interface DiagnosticsConfig {
    /** Warn if an entry file defines code ? */
    definedWithinEntry?: boolean;
    /** Warn if max analysis depth was reached when handling wildcard imports. */
    maxDepthReached?: boolean;
}
/** Final plugin options. */
type FinalPluginOptions = Required<Omit<PluginOptions, 'diagnostics'>> & {
    diagnostics: DiagnosticsConfig;
};
/** Performance-related duration. */
interface PerformanceDuration {
    /** Total duration. */
    time: number;
    /** Self duration. */
    self: number;
}
/** Plugin metrics. */
interface PluginMetrics {
    /** Time spent analyzing entries. */
    analysis: number;
    /** Time spent transforming files. */
    transform: number;
    /** Total process time of the plugin. */
    process: number;
    /** Number of triggered js/ts modules requests. */
    jsRequests: number;
    /** Number of triggered requests that are not js/ts modules. */
    otherRequests: number;
}
type Duration = [time: number, self: number];
/** Target entry data. */
interface EntryData {
    /** Source content of the entry file. */
    source: string;
    /** Cleaned-up content of the entry file. */
    updatedSource: string;
    /** Wildcard-based exports */
    wildcardExports?: WildcardExports;
    /** List of entry exports. */
    exports: EntryExports;
    /** Static analysis-wise depth at which the entry was registered. */
    depth: number;
    /** Time spent analyzing the entry (self). */
    self: number;
    /** Time spent analyzing the entry (inclusive). */
    time: number;
    /** Was the entry implicitly added to targets (through wildcards)? */
    isImplicit?: boolean;
    /** Indices of emitted `ctx.diagnostics` for this entry. */
    diagnostics: Set<number>;
    /** Number of analyzed imports. */
    importsCount: number;
    /** Times this entry was hit (this does not mean it was eventually requested). */
    hits: number;
}
/** Transformed file data. */
interface TransformData {
    /** Absolute path to transformed file. */
    id: string;
    /** Source content of the transformed file. */
    source: string;
    /** Transformed content of the transformed file. */
    transformed: string;
    /** Time spent transforming the file. */
    time: number;
    /** Transform's timestamp. */
    timestamp: number;
    /** Number of entries imported by the file.  */
    entriesMatched: number;
    /** Amount of potential requests avoided. */
    potentialRequestsAvoided: number;
}
/** Plugin diagnostic. */
interface Diagnostic {
    /** Diagnostic source file. */
    file?: string;
    /** Diagnostic name. */
    name: keyof DiagnosticsConfig;
    /** Diagnostic message. */
    message: string;
    /** Diagnostic context data. */
    data?: any;
}
/** Map of analyzed entries indexed by their absolute path. */
type PluginEntries = Map<EntryPath, EntryData>;
/** Import parameters. */
type ImportParams<T = string> = {
    /** Imported path. */
    path: T;
    /** Is it a default import? */
    importDefault: boolean;
    /** Original name of the entity (as exported by its source file). */
    originalName?: string;
    /** Alias of the entity (as imported from the entry by consomming code). */
    alias?: string;
    /** Determines whether the export represents some code defined within the file. */
    selfDefined?: boolean;
};
/** Caught wildcard exports. */
type WildcardExports = {
    /** Named wildcard exports (e.g. `import * as Something` or `export * as Something`). */
    named: Map<string, EntryPath>;
    /** Direct wildcard exports (e.g. `export * from './somewhere'`). */
    direct: string[];
};
/** Named export. */
type ExportName = string;
/** Resolved path of aggregated export (`export … from …`). */
type ExportOriginPath = string;
/** Entry exports map. */
type EntryExports = Map<ExportName, ImportParams<ExportOriginPath>>;
/** Resolved absolute path of target. */
type EntryPath = string;
/** Target definition through an object. */
type TargetObject = {
    path: EntryPath;
};
/** Tagret definition through Glob patterns. */
type TargetGlobPattern = {
    glob: string;
    globOptions?: Options;
};
/** Entry target passed to plugin options. */
type EntryTarget = EntryPath | TargetObject | TargetGlobPattern;
/** List of targets being processed by the plugin. */
type PluginTargets = EntryTarget[];
/** List of extended targets being processed by the plugin. */
type ExtendedTargets = Map<EntryPath, number>;
/** Supported log levels. */
type LogLevel = 'info' | 'warn' | 'error' | 'debug' | 'success';
/** Interface of a single log. */
interface Log {
    /** Log level. */
    level: LogLevel;
    /** Message content of the log. */
    content: string;
    /** Timestamp the log was recorded at. */
    timestamp: number;
}
/** Vite's base logger. */
type BaseLogger = Pick<Logger$1, Exclude<LogLevel, 'debug' | 'success'>>;
/** Available debugger events and their payload. */
type DebuggerEvents = {
    increaseProcessTime: [number];
    increaseTransformTime: [number];
    incrementJsRequests: [];
    incrementOtherRequests: [];
    increaseEntryHits: [EntryPath];
    registerTransform: [TransformData];
    registerLog: [Log];
};

/** Plugin's event bus used to communicate with the debugger. */
declare class EventBus {
    /** Event emitter. */
    private emitter;
    /**
     * Executes subscribed callback when a registered event is emitted by the debugger.
     * @param eventName Received event name.
     * @param callback Callback to execute when the event is emitted
     */
    on: <T extends keyof DebuggerEvents>(eventName: T, callback: (...args: DebuggerEvents[T]) => void) => EventEmitter<[never]>;
    /**
     * Sends an event to the debugger.
     * @param eventName Event name to send.
     * @param args Arguments to send along with the event.
     */
    emit: <T extends keyof DebuggerEvents>(event: T, ...args: DebuggerEvents[T]) => boolean;
    /**
     * Subscribe to events that may be emitted by the debugger.
     * @param cb Callback to execute when the relevant event is emitted.
     */
    subscribe(cb: (event: keyof DebuggerEvents, data: any) => void): void;
}

/** Plugin's logger. */
declare class Logger implements BaseLogger {
    /** Base Vite logger. */
    private baseLogger;
    /** Is debug mode enabled? */
    private debugMode;
    /** List of all logs. */
    logs: Log[];
    /** Plugin's Event Bus. */
    eventBus?: EventBus;
    constructor(
    /** Base Vite logger. */
    baseLogger: Logger$1, 
    /** Is debug mode enabled? */
    debugMode: boolean);
    /**
     * Logs a debug message.
     * @param content Log message content.
     * @param options Log options.
     */
    debug: (content: string, options?: LogOptions) => void;
    /**
     * Logs an information message.
     * @param content Information message.
     * @param options Log options.
     * @param faded Is the information of secondary importance?
     */
    info: (content: string, options?: LogOptions, faded?: boolean) => void;
    /**
     * Logs a warning message.
     * @param content Warning message.
     * @param options Log options.
     */
    warn: Logger$1['warn'];
    /**
     * Logs an error.
     * @param content Error message.
     * @param options Log options.
     */
    error: Logger$1['error'];
    /**
     * Logs a success message.
     * @param content Success message.
     * @param options Log options.
     */
    success: Logger$1['info'];
    /**
     * Attaches the event bus to the logger so that logs may be transmitted to debugger.
     * @param eventBus Event bus instance.
     */
    getOntoEventBus(eventBus: EventBus): void;
    /**
     * Adds a log to the list and notifies debugger through the event bus.
     * @param content Log message content.
     * @param level Log level.
     */
    private addLog;
}

/** Plugin's diagnostics. */
declare class Diagnostics {
    options: Required<FinalPluginOptions>;
    /** List of all emitted diagnostics */
    list: Diagnostic[];
    /** Map of all emitted diagnostics indices indexed by file path. */
    listPerPath: Map<string, number[]>;
    constructor(options: Required<FinalPluginOptions>);
    /**
     * Emits a diagnostic.
     * @param name Diagnostic name.
     * @param message Diagnostic message.
     * @param data Diagnostic context data.
     */
    add(name: keyof DiagnosticsConfig, message: string, data?: any): number;
    /**
     * Determines whether a specific diagnostic is enabled.
     * @param name Diagnostic name.
     */
    isEnabled(name: keyof DiagnosticsConfig): boolean;
}
declare const DiagnosticKinds: {
    definedWithinEntry: (entryPath: string) => {
        base: string;
        name: "definedWithinEntry";
        message: string;
    };
    maxDepthReached: (path: string, importedFrom: string) => {
        base: string;
        name: "maxDepthReached";
        message: string;
    };
};

declare class Timer {
    logger: Logger;
    constructor(logger: Logger);
    /**
     * Measures the duration of a logic execution.
     * @param title Title of the execution logic.
     * @param callback Function to trigger and measure.
     * @param silent Set to `true` if the execution duration should not be logged.
     */
    measure<Title extends string, Callback extends (...args: any[]) => any, Silent extends boolean, Return = Callback extends (...args: any[]) => infer R ? R : any>(title: Title, callback: Callback, silent?: Silent): Promise<PerformanceDuration & {
        out?: Awaited<Return>;
    }>;
    /**
     * Measures both self and total duration of a logic execution and returns them
     * as a `Duration` tuple. This method wraps the `measure` method so that one
     * can fine-tune differences between self and total times.
     * @param title Title of the execution logic.
     * @param callback Function to trigger and measure.
     */
    time(label: string, callback: (nonSelfTime: number) => Promise<number>): Promise<Duration>;
}

/** Plugin's context. */
declare class Context {
    options: Required<FinalPluginOptions>;
    config: ResolvedConfig;
    /** Vite resolver. */
    resolver: ResolveFn;
    /** Map of analyzed entries. */
    entries: PluginEntries;
    /** Map of registered targets. */
    targets: ExtendedTargets;
    /** Plugin's logger. */
    logger: Logger;
    /** Plugin's diagnostics. */
    diagnostics: Diagnostics;
    /** Plugin's performance utilities. */
    timer: Timer;
    /** Plugin's Event Bus. */
    eventBus?: EventBus;
    /** Plugin's metrics. */
    metrics: PluginMetrics;
    /**
     * Creates the plugin context.
     * @param options Plugin options.
     * @param config Resolved Vite config.
     */
    constructor(options: Required<FinalPluginOptions>, config: ResolvedConfig);
    /**  Initializes the plugin context. */
    init(): Promise<void>;
    /**
     * Loads a file from the entries.
     * @param id Path to the file.
     */
    loadFile(id: string): string | undefined;
    /**
     * Transforms a file (if needed).
     * @param code Source code of the file.
     * @param id Path to the file.
     */
    transformFile(code: string, id: string): Promise<string | undefined>;
    /**
     * Checks if hot update matches any of the entries.
     * If it does, re-triggers the analysis of that entry.
     * @param id Path to the file.
     */
    checkUpdate(id: string): Promise<void>;
    /** Registers targets from the plugin options. */
    private registerTargets;
}

declare const name = "vite-plugin-entry-shaking";
declare function createEntryShakingPlugin(userOptions: PluginOptions): Promise<PluginOption>;

export { Context, type DebuggerEvents, type Diagnostic, DiagnosticKinds, type EntryData, type EntryExports, type Log, type LogLevel, type PluginEntries, type PluginMetrics, type PluginOptions, type TransformData, type WildcardExports, createEntryShakingPlugin, createEntryShakingPlugin as default, name };
