'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const fs = require('fs');
const path = require('path');
const esModuleLexer = require('es-module-lexer');
const MagicString = require('magic-string');
const vite = require('vite');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const MagicString__default = /*#__PURE__*/_interopDefaultCompat(MagicString);

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const EOS = `\x1B[0m\x1B[29m`;
const COLORS = {
  cyan: `\x1B[36m`,
  gray: `\x1B[9m\x1B[90m`
};
const paint = (color, text) => `${COLORS[color]}${text}${EOS}`;
const logPrefix = paint("cyan", `[vite:entry-shaking]`);
const formatMessage = (msg) => `${logPrefix} ${msg}`;
class Logger {
  constructor(baseLogger, debugMode) {
    this.baseLogger = baseLogger;
    this.debugMode = debugMode;
    /** List of all logs. */
    __publicField$2(this, "logs", []);
    /** Plugin's Event Bus. */
    __publicField$2(this, "eventBus");
    /**
     * Logs a debug message.
     * @param content Log message content.
     * @param options Log options.
     */
    __publicField$2(this, "debug", (content, options) => {
      if (this.debugMode)
        this.baseLogger?.info?.(content, options);
      this.addLog(content, "debug");
    });
    /**
     * Logs an information message.
     * @param content Information message.
     * @param options Log options.
     * @param faded Is the information of secondary importance?
     */
    __publicField$2(this, "info", (content, options, faded = false) => {
      const msg = formatMessage(faded ? paint("gray", content) : content);
      if (this.debugMode)
        this.baseLogger?.info?.(msg, options);
      this.addLog(content, "info");
    });
    /**
     * Logs a warning message.
     * @param content Warning message.
     * @param options Log options.
     */
    __publicField$2(this, "warn", (content, options) => {
      const msg = formatMessage(content);
      if (this.debugMode)
        this.baseLogger?.warn?.(msg, options);
      this.addLog(content, "warn");
    });
    /**
     * Logs an error.
     * @param content Error message.
     * @param options Log options.
     */
    __publicField$2(this, "error", (content, options) => {
      const msg = formatMessage(content);
      if (this.debugMode)
        this.baseLogger?.error?.(msg, options);
      this.addLog(content, "error");
    });
    /**
     * Logs a success message.
     * @param content Success message.
     * @param options Log options.
     */
    __publicField$2(this, "success", (content, options) => {
      const msg = formatMessage(content);
      if (this.debugMode)
        this.baseLogger?.info?.(msg, options);
      this.addLog(content, "success");
    });
  }
  /**
   * Attaches the event bus to the logger so that logs may be transmitted to debugger.
   * @param eventBus Event bus instance.
   */
  getOntoEventBus(eventBus) {
    this.eventBus = eventBus;
  }
  /**
   * Adds a log to the list and notifies debugger through the event bus.
   * @param content Log message content.
   * @param level Log level.
   */
  addLog(content, level) {
    this.logs.push({ content, level, timestamp: Date.now() });
    this.eventBus?.emit("registerLog", { content, level, timestamp: Date.now() });
  }
}

function cleanupEntry$1(rawEntry, entryMap, exps) {
  return methods$4.reformatRemainingExports(
    methods$4.removeEmptyExports(methods$4.removeResolvedExports(rawEntry, entryMap, exps))
  );
}
function reformatRemainingExports(content) {
  return content.replace(/export {([^}]*)}/gm, (_, exps) => {
    const reformattedExport = exps.split(",").map((item) => item.trim()).filter((item) => item !== "").join(",");
    return `export { ${reformattedExport} }`;
  });
}
const removeEmptyExports = (content) => content.replace(/(export {[^\w}]*}.*;?)/gm, "");
function removeResolvedExports(rawEntry, entryMap, exps) {
  const output = new MagicString__default(rawEntry);
  const replace = /* @__PURE__ */ new Set([]);
  exps.forEach(({ n: exportedName, s: lineStart, e: lineEnd }) => {
    const exported = entryMap.get(exportedName);
    if (exported && !exported.selfDefined && exportedName !== "default") {
      replace.add([lineStart, lineEnd, ""]);
    }
  });
  replace.forEach(([start, end, replacement]) => {
    output.overwrite(start, end, replacement);
  });
  return output.toString().replace(/(\w*\s*as\s*)([,}])/gm, "$2");
}
const methods$4 = {
  cleanupEntry: cleanupEntry$1,
  reformatRemainingExports,
  removeEmptyExports,
  removeResolvedExports
};

function parseImportStatement(statement) {
  const output = {
    namedImports: [],
    defaultImports: [],
    wildcardImport: void 0
  };
  const [, , importContent] = statement.match(/(im|ex)port\s+((.|\n)*)\s+from/) ?? [, , void 0];
  return importContent ? methods$3.parseImportStatementContent(importContent) : output;
}
function parseImportStatementContent(importContent) {
  const output = {
    namedImports: [],
    defaultImports: [],
    wildcardImport: void 0
  };
  const registerImport = (target) => (s) => {
    const name = s.trim().replace(/\n/g, " ");
    if (name.length)
      output[target].push(name);
  };
  const registerNamedImport = registerImport("namedImports");
  const registerDefaultImport = registerImport("defaultImports");
  const registerWildcardImport = (s) => {
    output.wildcardImport = s.trim();
  };
  const def = [, void 0];
  const [namedImportsStatement, namedImportsContent] = importContent.match(/{([\s\S]*)}/) ?? def;
  if (namedImportsStatement && namedImportsContent) {
    importContent = importContent.replace(namedImportsStatement, "");
    namedImportsContent.split(",").forEach((namedImport) => {
      const name = namedImport.split(/\s+as\s+/).map((param) => param.trim());
      if (name.length === 1) {
        registerNamedImport(name[0]);
      } else {
        const [originalName, alias] = name;
        if (originalName === "default") {
          registerDefaultImport(alias);
        } else {
          registerNamedImport(namedImport);
        }
      }
    });
  }
  const defaultImport = importContent.replace(/,/g, "").trim();
  if (defaultImport.startsWith("*")) {
    registerWildcardImport(defaultImport);
  } else if (defaultImport.length) {
    registerDefaultImport(defaultImport);
  }
  return output;
}
function parseImportParams(importString) {
  const [name, alias] = importString.trim().split(/\s+as\s+/);
  return { name, alias };
}
const methods$3 = {
  parseImportStatementContent,
  parseImportStatement,
  parseImportParams
};

const parallelize = async (a, cb) => Promise.all(a.map(cb));
const loadEventBus = async () => await import('./chunks/event-bus.cjs');
const loadDebugger = async () => {
  const debuggerPkgName = "vite-plugin-entry-shaking-debugger";
  try {
    const debuggerPkg = await import(debuggerPkgName);
    return debuggerPkg;
  } catch {
    throw new Error(`Using the \`debug\` option requires installing \`${debuggerPkgName}\``);
  }
};
const getAllTargetPaths = async (targets) => {
  const paths = [];
  for (const target of targets) {
    if (typeof target === "string")
      paths.push(target);
    else if (isObjectDefinition(target))
      paths.push(target.path);
    else if (isGlobPatternDefinition(target)) {
      const { glob, globOptions } = target;
      const globSync = await loadFastGlob();
      const options = { ignore: ["**/node_modules/**"], ...globOptions ?? {} };
      const matches = globSync(glob, options).map((path) => path);
      paths.push(...matches);
    } else {
      throw new Error("Invalid target definition.");
    }
  }
  return paths;
};
const loadFastGlob = async () => {
  const {
    default: { globSync }
  } = await import('fast-glob').catch(() => {
    throw new Error("Could not find fast-glob");
  });
  return globSync;
};
const isObjectDefinition = (target) => typeof target === "object" && "path" in target;
const isGlobPatternDefinition = (target) => typeof target === "object" && "glob" in target;
const Utils = {
  parallelize,
  loadEventBus,
  loadDebugger,
  getAllTargetPaths,
  isObjectDefinition,
  isGlobPatternDefinition
};

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Diagnostics {
  constructor(options) {
    this.options = options;
    /** List of all emitted diagnostics */
    __publicField$1(this, "list", []);
    /** Map of all emitted diagnostics indices indexed by file path. */
    __publicField$1(this, "listPerPath", /* @__PURE__ */ new Map());
  }
  /**
   * Emits a diagnostic.
   * @param name Diagnostic name.
   * @param message Diagnostic message.
   * @param data Diagnostic context data.
   */
  add(name, message, data) {
    this.list.push({ name, message, data });
    const diagnosticIndex = this.list.length - 1;
    if (data.source) {
      if (!this.listPerPath.has(data.source)) {
        this.listPerPath.set(data.source, [diagnosticIndex]);
      } else {
        this.listPerPath.get(data.source)?.push(diagnosticIndex);
      }
    }
    return diagnosticIndex;
  }
  /**
   * Determines whether a specific diagnostic is enabled.
   * @param name Diagnostic name.
   */
  isEnabled(name) {
    return this.options.diagnostics?.[name] === true;
  }
}
const DiagnosticKinds = {
  definedWithinEntry: (entryPath) => {
    const name = "definedWithinEntry";
    const base = `Entry file "${entryPath}" exports code it defines and imports code from other modules.`;
    const message = `${base} Such imports are never cleaned up because they could have side-effects and be consumed by code defined by the entry file. Determining whether such imports are unused could be expensive. This means that if you were to import any entity defined by that entry file, it could result in unnecessary requests.
You may ignore this warning by setting the \`diagnostics.definedWithinEntry\` option to false.`;
    return { base, name, message };
  },
  maxDepthReached: (path, importedFrom) => {
    const name = "maxDepthReached";
    const base = `Max depth reached at path "${importedFrom}", skipping wildcard import analysis of "${path}"\u2026`;
    const message = `${base} Such imports are never cleaned up because they could have side-effects and be consumed by code defined by the entry file. Determining whether such imports are unused could be expensive. This means that if you were to import any entity defined by that entry file, it could result in unnecessary requests.
You may ignore this warning by setting the \`diagnostics.definedWithinEntry\` option to false.`;
    return { base, name, message };
  }
};

async function analyzeEntries(ctx) {
  const { time, out } = await ctx.timer.measure("Analysis of target entry files", async () => {
    const targets = [...ctx.targets.entries()];
    await Utils.parallelize(targets, async ([path, depth]) => {
      const absolutePath = await ctx.resolver(path) ?? path;
      await methods$2.analyzeEntry(ctx, absolutePath, depth);
    });
    return ctx.entries;
  });
  ctx.logger.success(`Entries analysis complete`);
  ctx.metrics.analysis = time;
  ctx.metrics.process = time;
  return out;
}
async function analyzeEntry(ctx, entryPath, depth) {
  if (ctx.entries.has(entryPath))
    return [0, 0];
  return await methods$2.doAnalyzeEntry(ctx, entryPath, depth).catch((e) => {
    const message = `Could not analyze entry file "${entryPath}"`;
    console.error(e);
    ctx.logger.error(message);
    throw new Error(message);
  });
}
async function doAnalyzeEntry(ctx, entryPath, depth) {
  const exportsMap = /* @__PURE__ */ new Map([]);
  const wildcardExports = { named: /* @__PURE__ */ new Map([]), direct: [] };
  const diagnostics = /* @__PURE__ */ new Set();
  let exps = [];
  let source = "";
  let updatedSource = "";
  let charactersDiff = 0;
  let definesExportedCode = false;
  let importsCount = 0;
  const [time, self] = await ctx.timer.time(
    `Analysis of entry "${entryPath}"`,
    async (nonselfTime) => {
      await esModuleLexer.init;
      source = fs.readFileSync(path.resolve(entryPath), "utf-8");
      const defaultImport = { path: entryPath, importDefault: true };
      const analyzedImports = /* @__PURE__ */ new Map([["default", defaultImport]]);
      const [imports, exportList] = esModuleLexer.parse(source);
      exps = exportList;
      for (const { n: path, ss: startPosition, se: endPosition } of imports) {
        const [t, s] = await methods$2.analyzeEntryImport(
          ctx,
          source,
          diagnostics,
          wildcardExports,
          analyzedImports,
          entryPath,
          path,
          startPosition,
          endPosition,
          depth
        );
        nonselfTime += t - s;
      }
      exps.forEach(({ n: namedExport, ln: localName }) => {
        const definesExports = methods$2.analyzeEntryExport(
          entryPath,
          exportsMap,
          wildcardExports,
          analyzedImports,
          namedExport,
          localName
        );
        if (!definesExportedCode && definesExports) {
          definesExportedCode = true;
        }
      });
      const cleanedUp = methods$2.cleanupEntry(
        ctx,
        diagnostics,
        entryPath,
        source,
        exportsMap,
        exps,
        definesExportedCode
      );
      importsCount += analyzedImports.size - 1;
      updatedSource = cleanedUp.updatedSource;
      charactersDiff = cleanedUp.charactersDiff;
      ctx.logger.debug(`Cleaned-up entry "${entryPath}" (-${charactersDiff} chars)`);
      return nonselfTime;
    }
  );
  ctx.entries.set(entryPath, {
    hits: 0,
    importsCount,
    exports: exportsMap,
    diagnostics,
    wildcardExports,
    source,
    updatedSource,
    depth,
    time,
    self
  });
  return [time, self];
}
function cleanupEntry(ctx, diagnostics, entryPath, source, exportsMap, exps, definesExportedCode) {
  const diagnosticName = "definedWithinEntry";
  const updatedSource = methods$4.cleanupEntry(source, exportsMap, exps);
  const charactersDiff = source.length - updatedSource.length;
  const requiresDiagnostic = ctx.diagnostics.isEnabled(diagnosticName) && definesExportedCode && updatedSource.includes("import");
  if (requiresDiagnostic) {
    const diagnostic = DiagnosticKinds[diagnosticName](entryPath);
    const diagnosticCtx = { source: entryPath };
    const diagnosticIndex = ctx.diagnostics.add(diagnosticName, diagnostic.message, diagnosticCtx);
    diagnostics.add(diagnosticIndex);
  }
  ctx.logger.debug(`Cleaned-up entry "${entryPath}" (-${charactersDiff} chars)`);
  return { updatedSource, charactersDiff };
}
async function analyzeEntryImport(ctx, rawEntry, diagnostics, wildcardExports, analyzedImports, entryPath, path, startPosition, endPosition, depth) {
  return await ctx.timer.time(`Analysis of entry import"`, async (nonselfTime) => {
    const statement = rawEntry.slice(startPosition, endPosition);
    const imports = methods$3.parseImportStatement(statement);
    imports.defaultImports.forEach((defaultImport) => {
      analyzedImports.set(defaultImport, { path, importDefault: true });
    });
    if (imports.wildcardImport) {
      const method = methods$2.registerWildcardImportIfNeeded;
      const [t, s] = await method(ctx, diagnostics, path, entryPath, depth);
      nonselfTime += t - (s ?? 0);
      const { alias } = methods$3.parseImportParams(imports.wildcardImport);
      if (alias) {
        wildcardExports.named.set(alias, path);
      } else {
        wildcardExports.direct.push(path);
      }
    }
    imports.namedImports.forEach((namedImport) => {
      const { name, alias } = methods$3.parseImportParams(namedImport);
      analyzedImports.set(alias ?? name, {
        path,
        importDefault: false,
        originalName: name
      });
    });
    return nonselfTime;
  });
}
function analyzeEntryExport(entryPath, exportsMap, wilcardExports, analyzedImports, namedExport, localName) {
  if (namedExport && !wilcardExports.named.has(namedExport)) {
    if (analyzedImports.has(namedExport)) {
      const { path, importDefault, originalName } = analyzedImports.get(namedExport);
      exportsMap.set(namedExport, { path, importDefault, originalName });
    } else if (localName && analyzedImports.has(localName)) {
      const { path, importDefault } = analyzedImports.get(localName);
      exportsMap.set(namedExport, { path, importDefault, originalName: localName });
    } else {
      exportsMap.set(namedExport, {
        path: entryPath,
        importDefault: false,
        originalName: localName,
        selfDefined: true
      });
      return true;
    }
  }
}
async function registerWildcardImportIfNeeded(ctx, diagnostics, path, importedFrom, depth) {
  return await ctx.timer.time(`Wilcard import analysis`, async (nonselfTime) => {
    const importsEntry = ctx.targets.get(path) === 0;
    const maxDepthReached = depth >= (ctx.options.maxWildcardDepth ?? 0);
    if (maxDepthReached) {
      const diagnosticName = "maxDepthReached";
      const diagnostic = DiagnosticKinds[diagnosticName](path, importedFrom);
      if (importsEntry) {
        ctx.logger.debug(diagnostic.base);
      } else {
        if (ctx.diagnostics.isEnabled(diagnosticName)) {
          const diagnosticCtx = { path, importedFrom, source: importedFrom };
          const diagnosticIndex = ctx.diagnostics.add(
            diagnosticName,
            diagnostic.message,
            diagnosticCtx
          );
          diagnostics.add(diagnosticIndex);
          ctx.logger.debug(diagnostic.base);
        }
        return 0;
      }
    }
    const [t, s] = await methods$2.registerWildcardImport(ctx, path, importedFrom, depth + 1);
    return nonselfTime + t - s;
  });
}
async function registerWildcardImport(ctx, path, importedFrom, depth) {
  return await ctx.timer.time("Register wildcard import", async (nonselfTime) => {
    const resolvedPath = await ctx.resolver(path, importedFrom);
    if (!resolvedPath || ctx.targets.has(resolvedPath))
      return nonselfTime;
    ctx.logger.info(`Adding implicit target "${path}" because of a wildcard at "${importedFrom}"`);
    ctx.targets.set(resolvedPath, depth);
    const [t] = await methods$2.analyzeEntry(ctx, resolvedPath, depth);
    return nonselfTime + t;
  });
}
const methods$2 = {
  analyzeEntries,
  analyzeEntry,
  doAnalyzeEntry,
  cleanupEntry,
  analyzeEntryImport,
  analyzeEntryExport,
  registerWildcardImportIfNeeded,
  registerWildcardImport
};

const SOURCE_QUERY_SUFFIX = "source";
function addSourceQuerySuffix(id) {
  const idEntities = id.split("?");
  const idParams = idEntities.length > 1 ? idEntities.pop() : void 0;
  const sourceId = idEntities.join("?");
  const params = new URLSearchParams(idParams);
  params.set(SOURCE_QUERY_SUFFIX, "1");
  return `${sourceId}?${params.toString()}`;
}
function parseId(id) {
  const idEntities = id.split("?");
  const idParams = idEntities.length > 1 ? idEntities.pop() : void 0;
  const sourceId = idEntities.join("?");
  const params = new URLSearchParams(idParams);
  const serveSource = params.get(SOURCE_QUERY_SUFFIX) === "1";
  params.delete(SOURCE_QUERY_SUFFIX);
  const url = params.size ? `${sourceId}?${params.toString()}` : sourceId;
  return { url, serveSource };
}

const WILDCARD_IMPORT_PREFIX = "import *";
const DYNAMIC_IMPORT_PREFIX = "import(";
const VITE_IGNORE_REGEX = /\/\*\s*@vite-ignore\s*\*\//;
async function analyzeImportStatement(ctx, src, code, entry, entryPath, startPosition, endPosition) {
  const isWildCardImport = catchWildcardImport(src, code, startPosition, endPosition, entryPath);
  if (isWildCardImport)
    return;
  const isDynamicImport = catchDynamicImport(src, code, startPosition, endPosition, entryPath);
  if (isDynamicImport)
    return;
  const imports = methods$1.getImportedEntryExports(code, startPosition, endPosition);
  const imported = await methods$1.getImportsMap(ctx, entry, entryPath, imports);
  const replacement = await methods$1.getImportReplacements(ctx, imported, entryPath);
  src.overwrite(startPosition, endPosition + 1, `${replacement.join(";\n")};`);
}
function getImportedEntryExports(code, startPosition, endPosition) {
  const source = code.slice(startPosition, endPosition);
  const imports = methods$3.parseImportStatement(source);
  return [
    ...imports.namedImports,
    ...imports.defaultImports.length ? imports.defaultImports.map((a) => `default as ${a}`) : []
  ];
}
async function getImportsMap(ctx, entry, entryPath, imports) {
  const map = /* @__PURE__ */ new Map([]);
  await Utils.parallelize(imports, async (importString) => {
    const { name, alias } = methods$3.parseImportParams(importString);
    const found = await methods$1.resolveImport(ctx, entry, entryPath, map, name, alias);
    if (found)
      return;
    map.set(entryPath, [...map.get(entryPath) ?? [], { name, importDefault: false }]);
  });
  return map;
}
async function resolveImport(ctx, entry, path, map, name, alias) {
  const namedImport = await methods$1.findNamedImport(ctx, entry, path, map, name, alias);
  if (namedImport)
    return true;
  const namedWildcard = await methods$1.findNamedWildcard(ctx, entry, path, map, name);
  if (namedWildcard)
    return true;
  const out = await methods$1.findDirectWildcardExports(ctx, entry, path, map, name, alias);
  return out !== void 0;
}
async function findNamedImport(ctx, entry, entryPath, map, name, alias) {
  const namedImport = entry.exports.get(name);
  if (namedImport) {
    const resolvedPath = await ctx.resolver(namedImport.path, entryPath);
    if (resolvedPath) {
      const { importDefault, originalName } = namedImport;
      map.set(resolvedPath, [
        ...map.get(resolvedPath) ?? [],
        { name, importDefault, originalName, alias }
      ]);
      return true;
    }
  }
}
async function findNamedWildcard(ctx, entry, entryPath, map, name) {
  const wildcardImport = entry.wildcardExports?.named.get(name);
  if (wildcardImport) {
    const resolvedPath = await ctx.resolver(wildcardImport, entryPath);
    const resolvedEntry = resolvedPath ? ctx.entries.get(resolvedPath) : void 0;
    if (resolvedPath && resolvedEntry) {
      map.set(resolvedPath, [
        ...map.get(resolvedPath) ?? [],
        { name: "*", importDefault: true, alias: name }
      ]);
      return true;
    }
  }
}
async function findDirectWildcardExports(ctx, entry, entryPath, map, name, alias) {
  const wildcardExports = entry.wildcardExports?.direct ?? [];
  for (const wildcardExportPath of wildcardExports) {
    const resolvedPath = await ctx.resolver(wildcardExportPath, entryPath);
    const resolvedEntry = resolvedPath ? ctx.entries.get(resolvedPath) : void 0;
    const resolvedExport = resolvedEntry ? resolvedEntry.exports.get(name) : void 0;
    if (resolvedPath) {
      if (resolvedExport) {
        map.set(resolvedPath, [
          ...map.get(resolvedPath) ?? [],
          { name, ...resolvedExport, alias }
        ]);
        return true;
      }
      if (resolvedEntry && resolvedEntry.wildcardExports) {
        const found = await methods$1.resolveImport(
          ctx,
          resolvedEntry,
          resolvedPath,
          map,
          name,
          alias
        );
        if (found)
          return true;
      }
    }
  }
}
async function getImportReplacements(ctx, imports, entryPath) {
  const replacement = [];
  for (const [importedPath, importedEntities] of imports) {
    const path = vite.normalizePath(importedPath);
    const content = await methods$1.resolveImportedEntities(ctx, importedEntities, entryPath, path);
    replacement.push(content.join("\n"));
  }
  return replacement;
}
async function resolveImportedEntities(ctx, imported, entryPath, path) {
  if (path !== entryPath && ctx.entries.has(path)) {
    return methods$1.resolveImportedCircularEntities(ctx, imported, path);
  }
  const imports = imported.map((entity) => methods$1.formatImportReplacement(entity));
  return [`import { ${imports.join(", ")} } from '${path}'`];
}
async function resolveImportedCircularEntities(ctx, imported, path) {
  const entityMap = /* @__PURE__ */ new Map();
  const originalEntry = ctx.entries.get(path);
  const wildcardImports = [];
  for (const entity of imported) {
    const { originalName, alias, name, importDefault } = entity;
    if (importDefault && name === "*") {
      wildcardImports.push(`import * as ${alias} from '${path}'`);
      continue;
    }
    if (originalName && originalEntry.exports.has(originalName)) {
      const originalImport = originalEntry.exports.get(originalName);
      const resolvedPath = await ctx.resolver(originalImport.path, path);
      if (!resolvedPath)
        continue;
      const resolvedImports = methods$1.formatImportReplacement({
        ...originalImport,
        name: originalName,
        alias
      });
      entityMap.set(resolvedPath, [...entityMap.get(resolvedPath) ?? [], resolvedImports]);
    }
  }
  const imports = [...entityMap.entries()];
  const formattedImports = imports.map(
    ([p, ents]) => `import { ${ents.join(", ")} } from '${p}'`
  );
  return [...formattedImports, ...wildcardImports];
}
function formatImportReplacement({ name, alias, originalName, importDefault }) {
  if (importDefault)
    return `default as ${alias ?? originalName ?? name}`;
  if (originalName)
    return `${originalName} as ${alias ?? name}`;
  return `${name}${alias ? ` as ${alias}` : ""}`;
}
function catchWildcardImport(src, code, startPosition, endPosition, entryPath) {
  const isWildCardImport = code.slice(startPosition, WILDCARD_IMPORT_PREFIX.length) === WILDCARD_IMPORT_PREFIX;
  if (isWildCardImport) {
    const [what] = code.slice(startPosition, endPosition).split("from");
    src.overwrite(
      startPosition,
      endPosition + 1,
      `${what.trim()} from "${addSourceQuerySuffix(entryPath)}";`
    );
  }
  return isWildCardImport;
}
function catchDynamicImport(src, code, startPosition, endPosition, entryPath) {
  const source = code.slice(startPosition, endPosition);
  const flatSource = source.replace(/\s/gm, "");
  const isViteIgnored = VITE_IGNORE_REGEX.test(flatSource);
  const isDynamicImport = flatSource.startsWith(DYNAMIC_IMPORT_PREFIX);
  const updatedPath = addSourceQuerySuffix(entryPath);
  if (isDynamicImport && !isViteIgnored) {
    src.overwrite(startPosition, endPosition, `import('${updatedPath}')`);
  }
  return isDynamicImport;
}
const methods$1 = {
  analyzeImportStatement,
  getImportedEntryExports,
  getImportsMap,
  resolveImport,
  findNamedImport,
  findNamedWildcard,
  findDirectWildcardExports,
  getImportReplacements,
  resolveImportedEntities,
  resolveImportedCircularEntities,
  formatImportReplacement,
  catchWildcardImport,
  catchDynamicImport
};

async function transformIfNeeded(ctx, id, code) {
  ctx.logger.debug(`Processing file "${id}"`, void 0);
  const isCandidate = methods.requiresTransform(ctx, id);
  const { out, time } = await ctx.timer.measure(
    "Transforming file if needed",
    async () => {
      if (!isCandidate) {
        ctx.logger.debug(`Ignored by options: ${id}`, void 0);
      } else {
        return await methods.transformImportsIfNeeded(ctx, id, code);
      }
    },
    true
  );
  ctx.eventBus?.emit("increaseProcessTime", time);
  ctx.eventBus?.emit("increaseTransformTime", time);
  return out;
}
async function transformImportsIfNeeded(ctx, id, code) {
  const [imports, exports] = esModuleLexer.parse(code);
  const importedStr = `${imports.length} imports`;
  const exportedStr = `${exports.length} exports`;
  ctx.logger.debug(`es-module-lexer returned ${importedStr} and ${exportedStr} for "${id}"`);
  let potentialRequestsAvoided = 0;
  const importedEntries = await methods.getEntryImports(ctx, id, imports);
  const entriesMatched = importedEntries.length;
  const { transformImports: transform } = methods;
  if (!entriesMatched) {
    const ignoredMessage = `Did not transform "${id}" because it does not import any registered target`;
    ctx.logger.debug(ignoredMessage, void 0);
    return;
  }
  importedEntries.forEach((entry) => {
    potentialRequestsAvoided += ctx.entries.get(entry)?.importsCount ?? 0;
    ctx.eventBus?.emit("increaseEntryHits", entry);
  });
  const { time, out } = await ctx.timer.measure(
    `Transforming file "${id}"`,
    async () => await transform(ctx, id, code, imports, exports)
  );
  ctx.eventBus?.emit("registerTransform", {
    id,
    source: code,
    transformed: out ?? code,
    time,
    timestamp: Date.now(),
    entriesMatched,
    potentialRequestsAvoided
  });
  return out;
}
async function transformImports(ctx, id, code, imports, exports) {
  await esModuleLexer.init;
  const src = new MagicString__default(code);
  const reexports = createReexportStatement(exports);
  for (const { n: path, ss: startPosition, se: endPosition } of imports) {
    const resolvedImport = path && await ctx.resolver(path, id);
    const entry = resolvedImport && ctx.entries.get(resolvedImport);
    if (entry) {
      await methods$1.analyzeImportStatement(
        ctx,
        src,
        code,
        entry,
        resolvedImport,
        startPosition,
        endPosition
      );
    }
  }
  const out = src.toString();
  return reexports.length ? [out, reexports].join("\n") : out;
}
function requiresTransform(ctx, id) {
  const extension = id.split(".").pop();
  const isIgnored = ctx.options.ignorePatterns.some((pattern) => id.match(pattern));
  return !isIgnored && ctx.options.extensions.includes(extension);
}
async function getEntryImports(ctx, id, imports) {
  try {
    return await imports.reduce(
      async (out, importParams) => {
        const { n: importPath } = importParams;
        const resolvedPath = importPath && await ctx.resolver(importPath, id);
        if (resolvedPath && ctx.entries.has(resolvedPath))
          (await out).push(resolvedPath);
        return out;
      },
      Promise.resolve([])
    );
  } catch (e) {
    return [];
  }
}
function createReexportStatement(exports) {
  const namedExports = exports.filter((e) => e.n !== void 0 && e.n !== "default" && e.ln === void 0).map(({ n }) => n);
  if (namedExports.length === 0)
    return "";
  return `export { ${namedExports.join(",")} };`;
}
const methods = {
  transformIfNeeded,
  transformImportsIfNeeded,
  transformImports,
  requiresTransform,
  getEntryImports,
  createReexportStatement
};

const extensions = ["js", "mjs", "ts", "mts"];
const ignorePatterns = [/node_modules/];
const defaultOptions = {
  targets: [],
  extensions,
  ignorePatterns,
  debug: false,
  maxWildcardDepth: 0,
  diagnostics: {
    definedWithinEntry: true,
    maxDepthReached: true
  }
};
const mergeOptions = (userOptions) => ({
  ...defaultOptions,
  ...userOptions,
  ignorePatterns: mergeIgnorePatterns(userOptions),
  diagnostics: setDiagnosticsOption(userOptions),
  maxWildcardDepth: userOptions.maxWildcardDepth ?? 0,
  targets: userOptions.targets.map((target) => {
    if (typeof target === "string")
      return vite.normalizePath(target);
    if (isObjectDefinition(target))
      return vite.normalizePath(target.path);
    return target;
  })
});
const mergeIgnorePatterns = (userOptions) => [
  ...defaultOptions.ignorePatterns,
  ...userOptions.ignorePatterns ?? []
];
const setDiagnosticsOption = (userOptions) => {
  const { diagnostics } = defaultOptions;
  const keys = Object.keys(diagnostics);
  const setAll = (v) => keys.reduce((out, k) => ({ ...out, [k]: v }), {});
  switch (userOptions.diagnostics) {
    case void 0:
      return diagnostics;
    case true:
      return setAll(true);
    case false:
      return setAll(false);
    default:
      return { ...diagnostics, ...userOptions.diagnostics };
  }
};

class Timer {
  constructor(logger) {
    this.logger = logger;
  }
  /**
   * Measures the duration of a logic execution.
   * @param title Title of the execution logic.
   * @param callback Function to trigger and measure.
   * @param silent Set to `true` if the execution duration should not be logged.
   */
  async measure(title, callback, silent) {
    if (!silent)
      this.logger.debug(`${title} started`);
    const startTime = performance.now();
    const out = await callback();
    const time = performance.now() - startTime;
    if (!silent)
      this.logger.debug(`${title} ended, it took ${time.toFixed(2)}ms`);
    return { out, time, self: time };
  }
  /**
   * Measures both self and total duration of a logic execution and returns them
   * as a `Duration` tuple. This method wraps the `measure` method so that one
   * can fine-tune differences between self and total times.
   * @param title Title of the execution logic.
   * @param callback Function to trigger and measure.
   */
  async time(label, callback) {
    const nonselfTime = 0;
    const { time } = await this.measure(label, () => callback(nonselfTime), true);
    const self = time - nonselfTime;
    return [time, self];
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Context {
  /**
   * Creates the plugin context.
   * @param options Plugin options.
   * @param config Resolved Vite config.
   */
  constructor(options, config) {
    this.options = options;
    this.config = config;
    /** Vite resolver. */
    __publicField(this, "resolver");
    /** Map of analyzed entries. */
    __publicField(this, "entries", /* @__PURE__ */ new Map());
    /** Map of registered targets. */
    __publicField(this, "targets", /* @__PURE__ */ new Map());
    /** Plugin's logger. */
    __publicField(this, "logger");
    /** Plugin's diagnostics. */
    __publicField(this, "diagnostics");
    /** Plugin's performance utilities. */
    __publicField(this, "timer");
    /** Plugin's Event Bus. */
    __publicField(this, "eventBus");
    /** Plugin's metrics. */
    __publicField(this, "metrics", {
      analysis: 0,
      transform: 0,
      process: 0,
      jsRequests: 0,
      otherRequests: 0
    });
    this.resolver = config.createResolver();
    this.logger = new Logger(config.logger, false);
    this.logger.info("Plugin configuration resolved");
    this.diagnostics = new Diagnostics(this.options);
    this.timer = new Timer(this.logger);
  }
  /**  Initializes the plugin context. */
  async init() {
    await this.registerTargets();
    this.entries = await methods$2.analyzeEntries(this) ?? /* @__PURE__ */ new Map();
    if (this.options.debug) {
      const { EventBus } = await loadEventBus();
      this.eventBus = new EventBus();
      this.logger.getOntoEventBus(this.eventBus);
    }
  }
  /**
   * Loads a file from the entries.
   * @param id Path to the file.
   */
  loadFile(id) {
    const { url, serveSource } = parseId(id);
    const entry = this.entries.get(url);
    if (entry) {
      const version = serveSource ? "original" : "mutated";
      const output = serveSource ? entry.source : entry.updatedSource;
      this.logger.info(`Serving ${version} version entry file ${url}`);
      return output;
    }
  }
  /**
   * Transforms a file (if needed).
   * @param code Source code of the file.
   * @param id Path to the file.
   */
  async transformFile(code, id) {
    if (this.options.debug) {
      const ext = id.split(".").pop();
      const eventName = extensions.includes(ext) ? "incrementJsRequests" : "incrementOtherRequests";
      this.eventBus?.emit(eventName);
    }
    return await transformIfNeeded(this, id, code);
  }
  /**
   * Checks if hot update matches any of the entries.
   * If it does, re-triggers the analysis of that entry.
   * @param id Path to the file.
   */
  async checkUpdate(id) {
    const entryFile = this.entries.get(id);
    if (entryFile) {
      this.logger.info(`HMR requires new analysis of ${id}`);
      await methods$2.doAnalyzeEntry(this, id, entryFile.depth);
    }
  }
  /** Registers targets from the plugin options. */
  async registerTargets() {
    const paths = await Utils.getAllTargetPaths(this.options.targets);
    this.targets = new Map(paths.map((path) => [path, 0]));
  }
}

const name = "vite-plugin-entry-shaking";
async function createEntryShakingPlugin(userOptions) {
  const options = mergeOptions(userOptions);
  let context;
  return {
    name,
    apply: "serve",
    enforce: "post",
    async configResolved(config) {
      context = new Context(options, config);
      await context.init();
    },
    async configureServer(server) {
      if (context.options.debug) {
        const { attachDebugger } = await loadDebugger();
        attachDebugger(server, context);
      }
    },
    async load(id) {
      return context.loadFile(id);
    },
    async transform(code, id) {
      return await context.transformFile(code, id);
    },
    async handleHotUpdate({ file }) {
      await context.checkUpdate(file);
    }
  };
}

exports.DiagnosticKinds = DiagnosticKinds;
exports.createEntryShakingPlugin = createEntryShakingPlugin;
exports.default = createEntryShakingPlugin;
exports.name = name;
