import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useIsPresent } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import { Stack, Theme, createStyledContext, styled, useConfiguration, useEvent, useThemeName } from "@tamagui/core";
import { Dismissable } from "@tamagui/dismissable";
import { composeEventHandlers } from "@tamagui/helpers";
import { PortalItem } from "@tamagui/portal";
import { ThemeableStack } from "@tamagui/stacks";
import * as React from "react";
import { PanResponder } from "react-native";
import { TOAST_CONTEXT, TOAST_NAME } from "./constants";
import { ToastAnnounce } from "./ToastAnnounce";
import { Collection, useToastProviderContext } from "./ToastProvider";
import { VIEWPORT_PAUSE, VIEWPORT_RESUME } from "./ToastViewport";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var ToastImplFrame = styled(ThemeableStack, {
  name: "ToastImpl",
  focusable: !0,
  variants: {
    unstyled: {
      false: {
        focusStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$outlineColor"
        },
        backgroundColor: "$color6",
        borderRadius: "$10",
        paddingHorizontal: "$5",
        paddingVertical: "$2",
        marginHorizontal: "auto",
        marginVertical: "$1"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), _createStyledContext = createStyledContext({
  onClose: function() {
  }
}), ToastInteractiveProvider = _createStyledContext.Provider, useToastInteractiveContext = _createStyledContext.useStyledContext, ToastImpl = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var __scopeToast = props.__scopeToast, _props_type = props.type, type2 = _props_type === void 0 ? "foreground" : _props_type, durationProp = props.duration, open = props.open, onClose2 = props.onClose, onEscapeKeyDown = props.onEscapeKeyDown, onPause = props.onPause, onResume = props.onResume, onSwipeStart = props.onSwipeStart, onSwipeMove = props.onSwipeMove, onSwipeCancel = props.onSwipeCancel, onSwipeEnd = props.onSwipeEnd, _props_viewportName = props.viewportName, viewportName = _props_viewportName === void 0 ? "default" : _props_viewportName, toastProps = _object_without_properties(props, [
    "__scopeToast",
    "type",
    "duration",
    "open",
    "onClose",
    "onEscapeKeyDown",
    "onPause",
    "onResume",
    "onSwipeStart",
    "onSwipeMove",
    "onSwipeCancel",
    "onSwipeEnd",
    "viewportName"
  ]), isPresent = useIsPresent(), context = useToastProviderContext(__scopeToast), _React_useState = _sliced_to_array(React.useState(null), 2), node = _React_useState[0], setNode = _React_useState[1], composedRefs = useComposedRefs(forwardedRef, function(node2) {
    return setNode(node2);
  }), duration = durationProp || context.duration, closeTimerStartTimeRef = React.useRef(0), closeTimerRemainingTimeRef = React.useRef(duration), closeTimerRef = React.useRef(0), onToastAdd = context.onToastAdd, onToastRemove = context.onToastRemove, viewport = React.useMemo(function() {
    return context.viewports[viewportName];
  }, [
    context.viewports,
    viewportName
  ]), handleClose = useEvent(function() {
    if (isPresent) {
      if (isWeb) {
        var isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
        isFocusInToast && (viewport == null || viewport.focus());
      }
      onClose2();
    }
  }), startTimer = React.useCallback(function(duration2) {
    !duration2 || duration2 === Number.POSITIVE_INFINITY || (clearTimeout(closeTimerRef.current), closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime(), closeTimerRef.current = setTimeout(handleClose, duration2));
  }, [
    handleClose
  ]), handleResume = React.useCallback(function() {
    startTimer(closeTimerRemainingTimeRef.current), onResume == null || onResume();
  }, [
    onResume,
    startTimer
  ]), handlePause = React.useCallback(function() {
    var elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
    closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime, window.clearTimeout(closeTimerRef.current), onPause == null || onPause();
  }, [
    onPause
  ]);
  React.useEffect(function() {
    if (isWeb && viewport)
      return viewport.addEventListener(VIEWPORT_PAUSE, handlePause), viewport.addEventListener(VIEWPORT_RESUME, handleResume), function() {
        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause), viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
      };
  }, [
    viewport,
    duration,
    onPause,
    onResume,
    startTimer
  ]), React.useEffect(function() {
    open && !context.isClosePausedRef.current && startTimer(duration);
  }, [
    open,
    duration,
    context.isClosePausedRef,
    startTimer
  ]), React.useEffect(function() {
    return onToastAdd(), function() {
      return onToastRemove();
    };
  }, [
    onToastAdd,
    onToastRemove
  ]);
  var announceTextContent = React.useMemo(function() {
    return isWeb && node ? getAnnounceTextContent(node) : null;
  }, [
    node
  ]), isHorizontalSwipe = [
    "left",
    "right",
    "horizontal"
  ].includes(context.swipeDirection), animationDriver = useConfiguration().animationDriver;
  if (!animationDriver)
    throw new Error("Must set animations in tamagui.config.ts");
  var useAnimatedNumber = animationDriver.useAnimatedNumber, useAnimatedNumberStyle = animationDriver.useAnimatedNumberStyle, animatedNumber = useAnimatedNumber(0), _animationDriver_NumberView, _ref, AnimatedView = (_ref = (_animationDriver_NumberView = animationDriver.NumberView) !== null && _animationDriver_NumberView !== void 0 ? _animationDriver_NumberView : animationDriver.View) !== null && _ref !== void 0 ? _ref : Stack, animatedStyles = useAnimatedNumberStyle(animatedNumber, function(val) {
    "worklet";
    return {
      transform: [
        isHorizontalSwipe ? {
          translateX: val
        } : {
          translateY: val
        }
      ]
    };
  }), panResponder = React.useMemo(function() {
    return PanResponder.create({
      onMoveShouldSetPanResponder: function(e, gesture) {
        var shouldMove = shouldGrantGestureMove(context.swipeDirection, gesture);
        return shouldMove ? (onSwipeStart == null || onSwipeStart(e), !0) : !1;
      },
      onPanResponderGrant: function(e) {
        isWeb || handlePause == null || handlePause();
      },
      onPanResponderMove: function(e, gesture) {
        var _getGestureDistance = getGestureDistance(context.swipeDirection, gesture), x = _getGestureDistance.x, y = _getGestureDistance.y, delta = {
          x,
          y
        };
        animatedNumber.setValue(isHorizontalSwipe ? x : y, {
          type: "direct"
        }), isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold) && (onSwipeEnd == null || onSwipeEnd(e)), onSwipeMove == null || onSwipeMove(e);
      },
      onPanResponderEnd: function(e, param) {
        var dx = param.dx, dy = param.dy;
        isDeltaInDirection({
          x: dx,
          y: dy
        }, context.swipeDirection, context.swipeThreshold) || (isWeb || handleResume == null || handleResume(), onSwipeCancel == null || onSwipeCancel(e), animatedNumber.setValue(0, {
          type: "spring"
        }));
      }
    });
  }, [
    handlePause,
    handleResume
  ]), themeName = useThemeName();
  return /* @__PURE__ */ _jsxs(_Fragment, {
    children: [
      announceTextContent && /* @__PURE__ */ _jsx(ToastAnnounce, {
        __scopeToast,
        // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.
        role: "status",
        "aria-live": type2 === "foreground" ? "assertive" : "polite",
        "aria-atomic": !0,
        children: announceTextContent
      }),
      /* @__PURE__ */ _jsx(PortalItem, {
        hostName: viewportName ?? "default",
        children: /* @__PURE__ */ _jsx(ToastInteractiveProvider, {
          scope: __scopeToast,
          onClose: function() {
            handleClose();
          },
          children: /* @__PURE__ */ _jsx(Dismissable, {
            // asChild
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, function() {
              context.isFocusedToastEscapeKeyDownRef.current || handleClose(), context.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ _jsx(Theme, {
              forceClassName: !0,
              name: themeName,
              children: /* @__PURE__ */ _jsx(AnimatedView, _object_spread_props(_object_spread({}, panResponder == null ? void 0 : panResponder.panHandlers), {
                style: [
                  {
                    margin: "auto"
                  },
                  animatedStyles
                ],
                children: /* @__PURE__ */ _jsx(Collection.ItemSlot, {
                  __scopeCollection: __scopeToast || TOAST_CONTEXT,
                  children: /* @__PURE__ */ _jsx(ToastImplFrame, _object_spread(_object_spread_props(_object_spread({
                    // Ensure toasts are announced as status list or status when focused
                    role: "status",
                    "aria-live": "off",
                    "aria-atomic": !0,
                    "data-state": open ? "open" : "closed",
                    "data-swipe-direction": context.swipeDirection,
                    pointerEvents: "auto",
                    touchAction: "none",
                    userSelect: "none"
                  }, toastProps), {
                    ref: composedRefs
                  }), isWeb && {
                    onKeyDown: composeEventHandlers(props.onKeyDown, function(event) {
                      event.key === "Escape" && (onEscapeKeyDown == null || onEscapeKeyDown(event), onEscapeKeyDown == null || onEscapeKeyDown(event), event.defaultPrevented || (context.isFocusedToastEscapeKeyDownRef.current = !0, handleClose()));
                    })
                  }))
                })
              }))
            })
          })
        }, props.id)
      })
    ]
  });
});
ToastImpl.propTypes = {
  type: function(props) {
    if (props.type && ![
      "foreground",
      "background"
    ].includes(props.type)) {
      var error = "Invalid prop `type` supplied to `".concat(TOAST_NAME, "`. Expected `foreground | background`.");
      return new Error(error);
    }
    return null;
  }
};
var isDeltaInDirection = function(delta, direction) {
  var threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, deltaX = Math.abs(delta.x), deltaY = Math.abs(delta.y), isDeltaX = deltaX > deltaY;
  return direction === "left" || direction === "right" || direction === "horizontal" ? isDeltaX && deltaX > threshold : !isDeltaX && deltaY > threshold;
};
function getAnnounceTextContent(container) {
  if (!isWeb) return "";
  var textContent = [], childNodes = Array.from(container.childNodes);
  return childNodes.forEach(function(node) {
    if (node.nodeType === node.TEXT_NODE && node.textContent && textContent.push(node.textContent), isHTMLElement(node)) {
      var isHidden = node.ariaHidden || node.hidden || node.style.display === "none", isExcluded = node.dataset.toastAnnounceExclude === "";
      if (!isHidden)
        if (isExcluded) {
          var altText = node.dataset.toastAnnounceAlt;
          altText && textContent.push(altText);
        } else {
          var _textContent;
          (_textContent = textContent).push.apply(_textContent, _to_consumable_array(getAnnounceTextContent(node)));
        }
    }
  }), textContent;
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
var GESTURE_GRANT_THRESHOLD = 10, shouldGrantGestureMove = function(dir, param) {
  var dx = param.dx, dy = param.dy;
  return (dir === "horizontal" || dir === "left") && dx < -GESTURE_GRANT_THRESHOLD || (dir === "horizontal" || dir === "right") && dx > GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "up") && dy > -GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "down") && dy < GESTURE_GRANT_THRESHOLD;
}, getGestureDistance = function(dir, param) {
  var dx = param.dx, dy = param.dy, y = 0, x = 0;
  return dir === "horizontal" ? x = dx : dir === "left" ? x = Math.min(0, dx) : dir === "right" ? x = Math.max(0, dx) : dir === "vertical" ? y = dy : dir === "up" ? y = Math.min(0, dy) : dir === "down" && (y = Math.max(0, dy)), {
    x,
    y
  };
};
export {
  ToastImpl,
  ToastImplFrame,
  useToastInteractiveContext
};
//# sourceMappingURL=ToastImpl.js.map
