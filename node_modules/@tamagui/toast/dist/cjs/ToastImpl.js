var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var ToastImpl_exports = {};
__export(ToastImpl_exports, {
  ToastImpl: () => ToastImpl,
  ToastImplFrame: () => ToastImplFrame,
  useToastInteractiveContext: () => useToastInteractiveContext
});
module.exports = __toCommonJS(ToastImpl_exports);
var import_animate_presence = require("@tamagui/animate-presence"), import_compose_refs = require("@tamagui/compose-refs"), import_constants = require("@tamagui/constants"), import_core = require("@tamagui/core"), import_dismissable = require("@tamagui/dismissable"), import_helpers = require("@tamagui/helpers"), import_portal = require("@tamagui/portal"), import_stacks = require("@tamagui/stacks"), React = __toESM(require("react")), import_react_native = require("react-native-web"), import_constants2 = require("./constants"), import_ToastAnnounce = require("./ToastAnnounce"), import_ToastProvider = require("./ToastProvider"), import_ToastViewport = require("./ToastViewport"), import_jsx_runtime = require("react/jsx-runtime");
const ToastImplFrame = (0, import_core.styled)(import_stacks.ThemeableStack, {
  name: "ToastImpl",
  focusable: !0,
  variants: {
    unstyled: {
      false: {
        focusStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$outlineColor"
        },
        backgroundColor: "$color6",
        borderRadius: "$10",
        paddingHorizontal: "$5",
        paddingVertical: "$2",
        marginHorizontal: "auto",
        marginVertical: "$1"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), {
  Provider: ToastInteractiveProvider,
  useStyledContext: useToastInteractiveContext
} = (0, import_core.createStyledContext)({
  onClose() {
  }
}), ToastImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      viewportName = "default",
      ...toastProps
    } = props, isPresent = (0, import_animate_presence.useIsPresent)(), context = (0, import_ToastProvider.useToastProviderContext)(__scopeToast), [node, setNode] = React.useState(null), composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, (node2) => setNode(node2)), duration = durationProp || context.duration, closeTimerStartTimeRef = React.useRef(0), closeTimerRemainingTimeRef = React.useRef(duration), closeTimerRef = React.useRef(0), { onToastAdd, onToastRemove } = context, viewport = React.useMemo(() => context.viewports[viewportName], [context.viewports, viewportName]), handleClose = (0, import_core.useEvent)(() => {
      isPresent && (import_constants.isWeb && node?.contains(document.activeElement) && viewport?.focus(), onClose());
    }), startTimer = React.useCallback(
      (duration2) => {
        !duration2 || duration2 === Number.POSITIVE_INFINITY || (clearTimeout(closeTimerRef.current), closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime(), closeTimerRef.current = setTimeout(handleClose, duration2));
      },
      [handleClose]
    ), handleResume = React.useCallback(() => {
      startTimer(closeTimerRemainingTimeRef.current), onResume?.();
    }, [onResume, startTimer]), handlePause = React.useCallback(() => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
      closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime, window.clearTimeout(closeTimerRef.current), onPause?.();
    }, [onPause]);
    React.useEffect(() => {
      if (import_constants.isWeb && viewport)
        return viewport.addEventListener(import_ToastViewport.VIEWPORT_PAUSE, handlePause), viewport.addEventListener(import_ToastViewport.VIEWPORT_RESUME, handleResume), () => {
          viewport.removeEventListener(import_ToastViewport.VIEWPORT_PAUSE, handlePause), viewport.removeEventListener(import_ToastViewport.VIEWPORT_RESUME, handleResume);
        };
    }, [viewport, duration, onPause, onResume, startTimer]), React.useEffect(() => {
      open && !context.isClosePausedRef.current && startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]), React.useEffect(() => (onToastAdd(), () => onToastRemove()), [onToastAdd, onToastRemove]);
    const announceTextContent = React.useMemo(() => import_constants.isWeb && node ? getAnnounceTextContent(node) : null, [node]), isHorizontalSwipe = ["left", "right", "horizontal"].includes(
      context.swipeDirection
    ), { animationDriver } = (0, import_core.useConfiguration)();
    if (!animationDriver)
      throw new Error("Must set animations in tamagui.config.ts");
    const { useAnimatedNumber, useAnimatedNumberStyle } = animationDriver, animatedNumber = useAnimatedNumber(0), AnimatedView = animationDriver.NumberView ?? animationDriver.View ?? import_core.Stack, animatedStyles = useAnimatedNumberStyle(animatedNumber, (val) => {
      "worklet";
      return {
        transform: [isHorizontalSwipe ? { translateX: val } : { translateY: val }]
      };
    }), panResponder = React.useMemo(() => import_react_native.PanResponder.create({
      onMoveShouldSetPanResponder: (e, gesture) => shouldGrantGestureMove(context.swipeDirection, gesture) ? (onSwipeStart?.(e), !0) : !1,
      onPanResponderGrant: (e) => {
        import_constants.isWeb || handlePause?.();
      },
      onPanResponderMove: (e, gesture) => {
        const { x, y } = getGestureDistance(context.swipeDirection, gesture), delta = { x, y };
        animatedNumber.setValue(isHorizontalSwipe ? x : y, { type: "direct" }), isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold) && onSwipeEnd?.(e), onSwipeMove?.(e);
      },
      onPanResponderEnd: (e, { dx, dy }) => {
        isDeltaInDirection(
          { x: dx, y: dy },
          context.swipeDirection,
          context.swipeThreshold
        ) || (import_constants.isWeb || handleResume?.(), onSwipeCancel?.(e), animatedNumber.setValue(0, { type: "spring" }));
      }
    }), [handlePause, handleResume]), themeName = (0, import_core.useThemeName)();
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_ToastAnnounce.ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": !0,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.PortalItem, { hostName: viewportName ?? "default", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        ToastInteractiveProvider,
        {
          scope: __scopeToast,
          onClose: () => {
            handleClose();
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_dismissable.Dismissable,
            {
              onEscapeKeyDown: (0, import_helpers.composeEventHandlers)(onEscapeKeyDown, () => {
                context.isFocusedToastEscapeKeyDownRef.current || handleClose(), context.isFocusedToastEscapeKeyDownRef.current = !1;
              }),
              children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_core.Theme, { forceClassName: !0, name: themeName, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                AnimatedView,
                {
                  ...panResponder?.panHandlers,
                  style: [{ margin: "auto" }, animatedStyles],
                  children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ToastProvider.Collection.ItemSlot, { __scopeCollection: __scopeToast || import_constants2.TOAST_CONTEXT, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    ToastImplFrame,
                    {
                      role: "status",
                      "aria-live": "off",
                      "aria-atomic": !0,
                      "data-state": open ? "open" : "closed",
                      "data-swipe-direction": context.swipeDirection,
                      pointerEvents: "auto",
                      touchAction: "none",
                      userSelect: "none",
                      ...toastProps,
                      ref: composedRefs,
                      ...import_constants.isWeb && {
                        onKeyDown: (0, import_helpers.composeEventHandlers)(
                          props.onKeyDown,
                          (event) => {
                            event.key === "Escape" && (onEscapeKeyDown?.(event), onEscapeKeyDown?.(event), event.defaultPrevented || (context.isFocusedToastEscapeKeyDownRef.current = !0, handleClose()));
                          }
                        )
                      }
                    }
                  ) })
                }
              ) })
            }
          )
        },
        props.id
      ) })
    ] });
  }
);
ToastImpl.propTypes = {
  type(props) {
    if (props.type && !["foreground", "background"].includes(props.type)) {
      const error = `Invalid prop \`type\` supplied to \`${import_constants2.TOAST_NAME}\`. Expected \`foreground | background\`.`;
      return new Error(error);
    }
    return null;
  }
};
const isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x), deltaY = Math.abs(delta.y), isDeltaX = deltaX > deltaY;
  return direction === "left" || direction === "right" || direction === "horizontal" ? isDeltaX && deltaX > threshold : !isDeltaX && deltaY > threshold;
};
function getAnnounceTextContent(container) {
  if (!import_constants.isWeb) return "";
  const textContent = [];
  return Array.from(container.childNodes).forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent && textContent.push(node.textContent), isHTMLElement(node)) {
      const isHidden = node.ariaHidden || node.hidden || node.style.display === "none", isExcluded = node.dataset.toastAnnounceExclude === "";
      if (!isHidden)
        if (isExcluded) {
          const altText = node.dataset.toastAnnounceAlt;
          altText && textContent.push(altText);
        } else
          textContent.push(...getAnnounceTextContent(node));
    }
  }), textContent;
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
const GESTURE_GRANT_THRESHOLD = 10, shouldGrantGestureMove = (dir, { dx, dy }) => (dir === "horizontal" || dir === "left") && dx < -GESTURE_GRANT_THRESHOLD || (dir === "horizontal" || dir === "right") && dx > GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "up") && dy > -GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "down") && dy < GESTURE_GRANT_THRESHOLD, getGestureDistance = (dir, { dx, dy }) => {
  let y = 0, x = 0;
  return dir === "horizontal" ? x = dx : dir === "left" ? x = Math.min(0, dx) : dir === "right" ? x = Math.max(0, dx) : dir === "vertical" ? y = dy : dir === "up" ? y = Math.min(0, dy) : dir === "down" && (y = Math.max(0, dy)), {
    x,
    y
  };
};
//# sourceMappingURL=ToastImpl.js.map
