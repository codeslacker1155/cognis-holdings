var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));
var import_arg = __toESM(require("arg")), import_chalk = __toESM(require("chalk")), import_add = require("./add.js"), import_utils = require("./utils"), import_static = require("@tamagui/static");
["exit", "SIGINT"].forEach((_) => {
  process.on(_, () => {
    (0, import_utils.disposeAll)(), process.exit();
  });
});
const COMMAND_MAP = {
  check: {
    description: "Checks your dependencies for inconsistent versions.",
    shorthands: [],
    flags: {
      "--help": Boolean,
      "--debug": Boolean,
      "--verbose": Boolean
    },
    async run() {
      const { _, ...flags2 } = (0, import_arg.default)(this.flags), options = await (0, import_utils.getOptions)({
        debug: flags2["--debug"] ? flags2["--verbose"] ? "verbose" : !0 : !1,
        loadTamaguiOptions: !0
      }), instance = await (0, import_static.checkDeps)(options.paths.root, {
        depType: ["dependencies", "devDependencies"]
      }), isNonTamaguiNamedDep = {
        "react-native-web-lite": !0,
        "react-native-web-internals": !0
      };
      for (const dep of instance.getDependencies())
        !dep.name.includes("tamagui") && !isNonTamaguiNamedDep[dep.name] || dep.isMismatching && console.warn(
          `-------------------------------------------------------------------------------------------------

\u26A0\uFE0F  [tamagui] Mis-matching dependency version found in: ${dep.name}

      This will cause errors in your app. To fix, make sure all tamagui dependencies
      in your repo are on on the same version.
          
      Other versions used in the repo: ${dep.versions.map((version) => version.version).join(", ")}

-------------------------------------------------------------------------------------------------`
        );
    }
  },
  generate: {
    description: "Builds your entire tamagui configuration and outputs any CSS.",
    shorthands: [],
    flags: {
      "--help": Boolean,
      "--debug": Boolean,
      "--verbose": Boolean
    },
    async run() {
      const { _, ...flags2 } = (0, import_arg.default)(this.flags), options = await (0, import_utils.getOptions)({
        debug: flags2["--debug"] ? flags2["--verbose"] ? "verbose" : !0 : !1,
        loadTamaguiOptions: !0
      });
      process.env.TAMAGUI_KEEP_THEMES = "1", await (0, import_static.loadTamagui)({
        ...options.tamaguiOptions,
        platform: "web"
      });
    }
  },
  "generate-themes": {
    shorthands: ["gt"],
    description: "Use to pre-build your themes",
    flags: {
      "--help": Boolean,
      "--debug": Boolean,
      "--verbose": Boolean
    },
    async run() {
      const { _, ...flags2 } = (0, import_arg.default)(this.flags), options = await (0, import_utils.getOptions)({
        debug: flags2["--debug"] ? flags2["--verbose"] ? "verbose" : !0 : !1
      }), [_cmd, inPath, outPath] = _;
      if (!inPath || !outPath)
        throw new Error(
          `Must supply both input and output paths, missing one (inPath: ${inPath}, outPath: ${outPath})`
        );
      const { generateThemes, writeGeneratedThemes } = require("@tamagui/generate-themes");
      try {
        const generated = await generateThemes(inPath);
        await writeGeneratedThemes(options.paths.dotDir, outPath, generated);
      } catch (err) {
        console.error(`Error generating themes: ${err}`);
        return;
      }
      console.info(`Successfully generated themes to ${outPath}`);
    }
  },
  add: {
    shorthands: ["a"],
    description: `Use to add fonts and icons to your monorepo. Supported types: ${import_add.generatedPackageTypes.join(
      ", "
    )}`,
    flags: {
      "--help": Boolean,
      "--debug": Boolean,
      "--verbose": Boolean
    },
    async run() {
      const { _, ...flags2 } = (0, import_arg.default)(this.flags), { installGeneratedPackage } = require("./add.js"), [cmd, type, path] = _;
      await installGeneratedPackage(type, path);
    }
  },
  build: {
    shorthands: ["b"],
    description: "Use to pre-build a Tamagui component directory",
    flags: {
      "--help": Boolean,
      "--debug": Boolean,
      "--verbose": Boolean,
      "--target": String,
      "--include": String,
      "--exclude": String
    },
    async run() {
      const { _, ...flags2 } = (0, import_arg.default)(this.flags), [_command, dir] = _, imported = await import("./build.js"), options = await (0, import_utils.getOptions)({
        debug: flags2["--debug"] ? flags2["--verbose"] ? "verbose" : !0 : !1
      });
      await imported.default.build({
        ...options,
        dir,
        include: flags2["--include"],
        target: flags2["--target"] || "web",
        exclude: flags2["--exclude"]
      });
    }
  },
  // update: {
  //   shorthands: [],
  //   description: `Update all tamagui packages within a monorepo`,
  //   flags: {},
  //   async run() {
  //     const { update } = await import('./update')
  //     await update()
  //   },
  // },
  "update-template": {
    shorthands: ["ut"],
    description: "Used to update your git repo with the source template. (e.g. Takeout)",
    flags: {
      "--help": Boolean,
      "--template-repo": String,
      "--ignored-patterns": String
    },
    async run() {
      const { _, ...flags2 } = (0, import_arg.default)(this.flags), { updateTemplate } = require("./update-template");
      if (!flags2["--template-repo"])
        throw new Error("--template-repo is required");
      await updateTemplate(
        flags2["--template-repo"],
        flags2["--ignored-patterns"]?.split(" ")
      );
    }
  }
}, commandEntries = Object.keys(COMMAND_MAP).flatMap((command2) => {
  const definition2 = COMMAND_MAP[command2];
  return [command2, ...definition2.shorthands].map((cmd) => [cmd, definition2]);
}), commands = Object.fromEntries(commandEntries), {
  _: [command],
  ...flags
} = (0, import_arg.default)(
  {
    "--help": Boolean,
    "--version": Boolean
  },
  {
    permissive: !0
  }
);
flags["--version"] && (console.info(require("../package.json").version), process.exit(0));
!command && flags["--help"] && (console.info(`$ tamagui

commands:

${Object.keys(COMMAND_MAP).map((key) => `  ${key}`).join(`
`)}`), process.exit(0));
command in commands || (console.error(), console.warn(import_chalk.default.yellow(`Not a valid command: ${command}`)), process.exit(1));
const definition = commands[command];
main();
async function main() {
  flags["--help"] && (console.info(`
$ tamagui ${command}: ${definition.description}
`), console.info(
    `Flags: ${Object.entries(definition.flags).map(([k, v]) => `${k} (${v.name})`)}`
  ), process.exit(0));
  const { _, ...cmdFlags } = (0, import_arg.default)(definition.flags);
  cmdFlags["--help"] && (console.info(`$ tamagui ${_}

    Flags: ${JSON.stringify(cmdFlags, null, 2)}

`), process.exit(0));
  try {
    await definition.run();
  } catch (err) {
    console.error(`Error running command: ${err.message}`);
  }
  process.exit(0);
}
//# sourceMappingURL=cli.js.map
