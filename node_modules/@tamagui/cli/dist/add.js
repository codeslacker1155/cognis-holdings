var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var add_exports = {};
__export(add_exports, {
  generatedPackageTypes: () => generatedPackageTypes,
  installGeneratedPackage: () => installGeneratedPackage
});
module.exports = __toCommonJS(add_exports);
var import_node_child_process = require("node:child_process"), import_node_fs = require("node:fs"), import_promises = require("node:fs/promises"), import_node_os = require("node:os"), import_node_path = __toESM(require("node:path")), import_chalk = __toESM(require("chalk")), import_change_case = require("change-case"), import_fs_extra = require("fs-extra"), import_marked = require("marked"), import_marked_terminal = __toESM(require("marked-terminal")), import_opener = __toESM(require("opener")), import_prompts = __toESM(require("prompts"));
import_marked.marked.setOptions({
  headerIds: !1,
  mangle: !1,
  renderer: new import_marked_terminal.default()
});
const home = (0, import_node_os.homedir)(), tamaguiDir = import_node_path.default.join(home, ".tamagui"), generatedPackageTypes = ["font", "icon"], installGeneratedPackage = async (type, packagesPath) => {
  if (packagesPath = packagesPath || import_node_path.default.join(process.cwd(), "packages"), !generatedPackageTypes.includes(type))
    throw new Error(
      `${type ? `Type "${type}" is Not supported.` : "No type provided."} Supported types: ${generatedPackageTypes.join(", ")}`
    );
  const repoName = type === "font" ? "tamagui-google-fonts" : "tamagui-iconify";
  console.info(`Setting up ${import_chalk.default.blueBright(tamaguiDir)}...`), await (0, import_fs_extra.ensureDir)(tamaguiDir);
  const tempDir = import_node_path.default.join(tamaguiDir, repoName);
  (0, import_node_fs.existsSync)(tempDir) && (0, import_node_fs.rmSync)(tempDir, { recursive: !0 });
  try {
    process.chdir(tamaguiDir);
    try {
      console.info("Attempting to clone with SSH"), (0, import_node_child_process.execSync)(
        `git clone -n --depth=1  --branch generated --filter=tree:0 git@github.com:tamagui/${repoName}.git`
      );
    } catch {
      console.info("SSH failed - Attempting to c  lone with HTTPS"), (0, import_node_child_process.execSync)(
        `git clone -n --depth=1 --branch generated --filter=tree:0 https://github.com/tamagui/${repoName}`
      );
    }
    process.chdir(tempDir), (0, import_node_child_process.execSync)(["git sparse-checkout set --no-cone meta", "git checkout"].join(" && "));
  } catch (error) {
    if (error instanceof Error)
      throw error?.stderr.includes("Repository not found") && (console.info(
        import_chalk.default.yellow(
          `You don't have access to Tamagui ${type === "font" ? "fonts" : "icons"}. Check \u{1F961} Tamagui Takeout (https://tamagui.dev/takeout) for more info.`
        )
      ), (0, import_opener.default)("https://tamagui.dev/takeout"), process.exit(0)), error;
  }
  const meta = JSON.parse(
    await (0, import_promises.readFile)(import_node_path.default.join(tamaguiDir, repoName, "meta", "data.json")).then(
      (r) => r.toString()
    )
  );
  console.info(
    import_chalk.default.gray(
      "Use \u21E7/\u21E9 to navigate. Use tab to cycle the result. Use Page Up/Page Down (on Mac: fn + \u21E7 / \u21E9) to change page. Hit enter to select the highlighted item below the prompt."
    )
  );
  const result = await (0, import_prompts.default)({
    name: "packageName",
    type: "autocomplete",
    message: type === "icon" ? "Pick an icon pack:" : type === "font" ? "Pick a font:" : "Pick one:",
    choices: Object.entries(meta).map(([slug, data]) => ({
      title: type === "font" ? `${slug}: ${data.weights.length} weights, ${data.styles.length} styles, ${data.subsets.length} subsets (https://fonts.google.com/specimen/${(0, import_change_case.pascalCase)(slug)})` : `${data.name}: ${data.total} icons, ${data.license.title} license (${data.author.url})`,
      value: slug
    }))
  }), packageName = `${type}-${result.packageName}`, packageDir = import_node_path.default.join(tempDir, "packages", packageName);
  process.chdir(tempDir), (0, import_node_child_process.execSync)(
    [`git sparse-checkout set --no-cone packages/${packageName}`, "git checkout"].join(
      " && "
    )
  );
  const finalDir = import_node_path.default.join(packagesPath, packageName);
  await (0, import_fs_extra.ensureDir)(packagesPath), await (0, import_fs_extra.copy)(packageDir, finalDir), console.info(), console.info(import_chalk.default.green(`Created the package under ${finalDir}`)), console.info();
  const readmePath = import_node_path.default.join(finalDir, "README.md");
  (0, import_node_fs.existsSync)(readmePath) && console.info(import_marked.marked.parse((0, import_fs_extra.readFileSync)(readmePath).toString()));
};
//# sourceMappingURL=add.js.map
