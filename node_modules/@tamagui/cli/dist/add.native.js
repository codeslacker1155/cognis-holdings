"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var add_exports = {};
__export(add_exports, {
  generatedPackageTypes: () => generatedPackageTypes,
  installGeneratedPackage: () => installGeneratedPackage
});
module.exports = __toCommonJS(add_exports);
var import_node_child_process = require("node:child_process"), import_node_fs = require("node:fs"), import_promises = require("node:fs/promises"), import_node_os = require("node:os"), import_node_path = __toESM(require("node:path")), import_chalk = __toESM(require("chalk")), import_change_case = require("change-case"), import_fs_extra = require("fs-extra"), import_marked = require("marked"), import_marked_terminal = __toESM(require("marked-terminal")), import_opener = __toESM(require("opener")), import_prompts = __toESM(require("prompts"));
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg), value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function _ts_generator(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    for (; _; ) try {
      if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      switch (y = 0, t && (op = [
        op[0] & 2,
        t.value
      ]), op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          return _.label++, {
            value: op[1],
            done: !1
          };
        case 5:
          _.label++, y = op[1], op = [
            0
          ];
          continue;
        case 7:
          op = _.ops.pop(), _.trys.pop();
          continue;
        default:
          if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1], t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2], _.ops.push(op);
            break;
          }
          t[2] && _.ops.pop(), _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [
        6,
        e
      ], y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
import_marked.marked.setOptions({
  headerIds: !1,
  mangle: !1,
  renderer: new import_marked_terminal.default()
});
var home = (0, import_node_os.homedir)(), tamaguiDir = import_node_path.default.join(home, ".tamagui"), generatedPackageTypes = [
  "font",
  "icon"
], installGeneratedPackage = function() {
  var _ref = _async_to_generator(function(type, packagesPath) {
    var repoName, tempDir, meta, _, result, packageName, packageDir, finalDir, readmePath;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (packagesPath = packagesPath || import_node_path.default.join(process.cwd(), "packages"), !generatedPackageTypes.includes(type))
            throw new Error("".concat(type ? 'Type "'.concat(type, '" is Not supported.') : "No type provided.", " Supported types: ").concat(generatedPackageTypes.join(", ")));
          return repoName = type === "font" ? "tamagui-google-fonts" : "tamagui-iconify", console.info("Setting up ".concat(import_chalk.default.blueBright(tamaguiDir), "...")), [
            4,
            (0, import_fs_extra.ensureDir)(tamaguiDir)
          ];
        case 1:
          _state.sent(), tempDir = import_node_path.default.join(tamaguiDir, repoName), (0, import_node_fs.existsSync)(tempDir) && (0, import_node_fs.rmSync)(tempDir, {
            recursive: !0
          });
          try {
            process.chdir(tamaguiDir);
            try {
              console.info("Attempting to clone with SSH"), (0, import_node_child_process.execSync)("git clone -n --depth=1  --branch generated --filter=tree:0 git@github.com:tamagui/".concat(repoName, ".git"));
            } catch {
              console.info("SSH failed - Attempting to c  lone with HTTPS"), (0, import_node_child_process.execSync)("git clone -n --depth=1 --branch generated --filter=tree:0 https://github.com/tamagui/".concat(repoName));
            }
            process.chdir(tempDir), (0, import_node_child_process.execSync)([
              "git sparse-checkout set --no-cone meta",
              "git checkout"
            ].join(" && "));
          } catch (error) {
            if (_instanceof(error, Error))
              throw error != null && error.stderr.includes("Repository not found") && (console.info(import_chalk.default.yellow("You don't have access to Tamagui ".concat(type === "font" ? "fonts" : "icons", ". Check \u{1F961} Tamagui Takeout (https://tamagui.dev/takeout) for more info."))), (0, import_opener.default)("https://tamagui.dev/takeout"), process.exit(0)), error;
          }
          return _ = JSON.parse, [
            4,
            (0, import_promises.readFile)(import_node_path.default.join(tamaguiDir, repoName, "meta", "data.json")).then(function(r) {
              return r.toString();
            })
          ];
        case 2:
          return meta = _.apply(JSON, [
            _state.sent()
          ]), console.info(import_chalk.default.gray("Use \u21E7/\u21E9 to navigate. Use tab to cycle the result. Use Page Up/Page Down (on Mac: fn + \u21E7 / \u21E9) to change page. Hit enter to select the highlighted item below the prompt.")), [
            4,
            (0, import_prompts.default)({
              name: "packageName",
              type: "autocomplete",
              message: type === "icon" ? "Pick an icon pack:" : type === "font" ? "Pick a font:" : "Pick one:",
              choices: Object.entries(meta).map(function(param) {
                var _param = _sliced_to_array(param, 2), slug = _param[0], data = _param[1];
                return {
                  title: type === "font" ? "".concat(slug, ": ").concat(data.weights.length, " weights, ").concat(data.styles.length, " styles, ").concat(data.subsets.length, " subsets (https://fonts.google.com/specimen/").concat((0, import_change_case.pascalCase)(slug), ")") : "".concat(data.name, ": ").concat(data.total, " icons, ").concat(data.license.title, " license (").concat(data.author.url, ")"),
                  value: slug
                };
              })
            })
          ];
        case 3:
          return result = _state.sent(), packageName = "".concat(type, "-").concat(result.packageName), packageDir = import_node_path.default.join(tempDir, "packages", packageName), process.chdir(tempDir), (0, import_node_child_process.execSync)([
            "git sparse-checkout set --no-cone packages/".concat(packageName),
            "git checkout"
          ].join(" && ")), finalDir = import_node_path.default.join(packagesPath, packageName), [
            4,
            (0, import_fs_extra.ensureDir)(packagesPath)
          ];
        case 4:
          return _state.sent(), [
            4,
            (0, import_fs_extra.copy)(packageDir, finalDir)
          ];
        case 5:
          return _state.sent(), console.info(), console.info(import_chalk.default.green("Created the package under ".concat(finalDir))), console.info(), readmePath = import_node_path.default.join(finalDir, "README.md"), (0, import_node_fs.existsSync)(readmePath) && console.info(import_marked.marked.parse((0, import_fs_extra.readFileSync)(readmePath).toString())), [
            2
          ];
      }
    });
  });
  return function(type, packagesPath) {
    return _ref.apply(this, arguments);
  };
}();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generatedPackageTypes,
  installGeneratedPackage
});
//# sourceMappingURL=add.js.map
