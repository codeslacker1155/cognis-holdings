var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var utils_exports = {};
__export(utils_exports, {
  disposeAll: () => disposeAll,
  ensure: () => ensure,
  getOptions: () => getOptions,
  loadTamagui: () => loadTamagui,
  registerDispose: () => registerDispose
});
module.exports = __toCommonJS(utils_exports);
var import_path = require("path"), import_static = require("@tamagui/static"), import_chalk = __toESM(require("chalk")), import_fs_extra = __toESM(require("fs-extra"));
async function getOptions({
  root = process.cwd(),
  tsconfigPath = "tsconfig.json",
  tamaguiOptions,
  host,
  debug,
  loadTamaguiOptions
} = {}) {
  const tsConfigFilePath = (0, import_path.join)(root, tsconfigPath);
  ensure(await import_fs_extra.default.pathExists(tsConfigFilePath), `No tsconfig found: ${tsConfigFilePath}`);
  const dotDir = (0, import_path.join)(root, ".tamagui");
  let pkgJson = {}, config = "";
  try {
    config = await getDefaultTamaguiConfigPath(), pkgJson = await (0, import_fs_extra.readJSON)((0, import_path.join)(root, "package.json"));
  } catch {
  }
  const filledOptions = {
    platform: "native",
    components: ["tamagui"],
    config,
    ...tamaguiOptions
  }, finalOptions = loadTamaguiOptions ? (0, import_static.loadTamaguiBuildConfigSync)(filledOptions) : filledOptions;
  return {
    mode: process.env.NODE_ENV === "production" ? "production" : "development",
    root,
    host: host || "127.0.0.1",
    pkgJson,
    debug,
    tsconfigPath,
    tamaguiOptions: finalOptions,
    paths: {
      root,
      dotDir,
      conf: (0, import_path.join)(dotDir, "tamagui.config.json"),
      types: (0, import_path.join)(dotDir, "types.json")
    }
  };
}
function ensure(condition, message) {
  condition || (console.error(import_chalk.default.red.bold("Error:"), import_chalk.default.yellow(`${message}`)), process.exit(1));
}
const defaultPaths = ["tamagui.config.ts", (0, import_path.join)("src", "tamagui.config.ts")];
let cachedPath = "";
async function getDefaultTamaguiConfigPath() {
  if (cachedPath) return cachedPath;
  const existing = (await Promise.all(defaultPaths.map((path) => (0, import_fs_extra.pathExists)(path)))).findIndex((x) => !!x), found = defaultPaths[existing];
  if (!found)
    throw new Error("No found tamagui.config.ts");
  return cachedPath = found, found;
}
let cached = null;
const loadTamagui = async (opts) => {
  const loaded = await (0, import_static.loadTamagui)({
    config: await getDefaultTamaguiConfigPath(),
    components: ["tamagui"],
    ...opts
  });
  return loaded && (cached = loaded), loaded;
}, disposers = /* @__PURE__ */ new Set();
function registerDispose(cb) {
  disposers.add(cb);
}
function disposeAll() {
  disposers.forEach((cb) => cb());
}
//# sourceMappingURL=utils.js.map
