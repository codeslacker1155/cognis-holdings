var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var extract_exports = {};
__export(extract_exports, {
  tamaguiExtractPlugin: () => tamaguiExtractPlugin
});
module.exports = __toCommonJS(extract_exports);
var StaticIn = __toESM(require("@tamagui/static"), 1), import_node_path = __toESM(require("node:path"), 1), import_vite = require("vite");
const Static = StaticIn.default || StaticIn, styleUpdateEvent = (fileId) => `tamagui-style-update:${fileId}`;
function tamaguiExtractPlugin(optionsIn) {
  if (optionsIn?.disable)
    return {
      name: "tamagui-extract"
    };
  let extractor = null;
  const cssMap = /* @__PURE__ */ new Map();
  let config, tamaguiOptions, server, virtualExt, disableStatic = !1;
  const getAbsoluteVirtualFileId = (filePath) => filePath.startsWith(config.root) ? filePath : (0, import_vite.normalizePath)(import_node_path.default.join(config.root, filePath));
  function isVite6AndNotClient(environment) {
    return environment?.name && environment.name !== "client";
  }
  return {
    name: "tamagui-extract",
    enforce: "pre",
    configureServer(_server) {
      server = _server;
    },
    buildEnd() {
      extractor?.cleanupBeforeExit();
    },
    config(userConf) {
      userConf.optimizeDeps ||= {}, userConf.optimizeDeps.include ||= [], userConf.optimizeDeps.include.push("@tamagui/core/inject-styles");
    },
    async configResolved(resolvedConfig) {
      extractor || (config = resolvedConfig, virtualExt = ".tamagui.css");
    },
    async resolveId(source) {
      if (isVite6AndNotClient(this.environment))
        return;
      extractor || (tamaguiOptions = Static.loadTamaguiBuildConfigSync({
        ...optionsIn,
        platform: "web"
      }), disableStatic = !!tamaguiOptions.disable, extractor = Static.createExtractor({
        logger: config.logger
      }), await extractor.loadTamagui({
        components: ["tamagui"],
        platform: "web",
        ...tamaguiOptions
      }));
      const [validId, query] = source.split("?");
      if (!validId.endsWith(virtualExt))
        return;
      const absoluteId = source.startsWith(config.root) ? source : getAbsoluteVirtualFileId(validId);
      if (cssMap.has(absoluteId))
        return absoluteId + (query ? `?${query}` : "");
    },
    /**
     * TODO
     *
     *   mainFields module:jsx breaks, so lets just have a mapping here
     *   where we load() and map it to the jsx path before transform
     *
     */
    load(id) {
      if (disableStatic || isVite6AndNotClient(this.environment))
        return;
      const [validId] = id.split("?");
      return cssMap.get(validId);
    },
    async transform(code, id, ssrParam) {
      if (disableStatic || isVite6AndNotClient(this.environment))
        return;
      const [validId] = id.split("?");
      if (!validId.endsWith(".tsx"))
        return;
      const firstCommentIndex = code.indexOf("// "), { shouldDisable, shouldPrintDebug } = Static.getPragmaOptions({
        source: firstCommentIndex >= 0 ? code.slice(firstCommentIndex) : "",
        path: validId
      });
      if (shouldPrintDebug && (console.trace(`Debugging file: ${id} in environment: ${this.environment?.name}`), console.info(`

Original source:
${code}

`)), shouldDisable)
        return;
      const extracted = await Static.extractToClassNames({
        extractor,
        source: code,
        sourcePath: validId,
        options: tamaguiOptions,
        shouldPrintDebug
      });
      if (!extracted)
        return;
      const rootRelativeId = `${validId}${virtualExt}`, absoluteId = getAbsoluteVirtualFileId(rootRelativeId);
      let source = extracted.js;
      if (extracted.styles) {
        if (server && cssMap.has(absoluteId) && cssMap.get(absoluteId) !== extracted.styles) {
          const { moduleGraph } = server, [module2] = Array.from(moduleGraph.getModulesByFile(absoluteId) || []);
          module2 && (moduleGraph.invalidateModule(module2), module2.lastHMRTimestamp = module2.lastInvalidationTimestamp || Date.now()), server.ws.send({
            type: "custom",
            event: styleUpdateEvent(absoluteId),
            data: extracted.styles
          });
        }
        source = `${source}
import "${rootRelativeId}";`, cssMap.set(absoluteId, extracted.styles);
      }
      return {
        code: source.toString(),
        map: extracted.map
      };
    }
  };
}
//# sourceMappingURL=extract.js.map
