import { existsSync, readFileSync, lstatSync } from "node:fs";
import { resolve, extname, dirname } from "node:path";
const DEFAULT_OPTIONS = {
  ensureFileExists: !1,
  esExtensionDefault: ".js",
  tryExtensions: [".js", ".mjs", ".cjs"],
  esExtensions: [".js", ".mjs", ".cjs"],
  includePackages: []
};
function FullySpecified(api, rawOptions) {
  api.assertVersion(7);
  const options = {
      ...DEFAULT_OPTIONS,
      ...rawOptions
    },
    importDeclarationVisitor = (path, state) => {
      const filePath = state.file.opts.filename;
      if (!filePath) return;
      const {
        node
      } = path;
      if (node.importKind === "type") return;
      const originalModuleSpecifier = node.source.value,
        fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(originalModuleSpecifier, {
          filePath,
          options
        });
      fullySpecifiedModuleSpecifier && (node.source.value = fullySpecifiedModuleSpecifier);
    },
    exportDeclarationVisitor = (path, state) => {
      const filePath = state.file.opts.filename;
      if (!filePath) return;
      const {
        node
      } = path;
      if (node.exportKind === "type") return;
      const source = node.source;
      if (!source) return;
      const originalModuleSpecifier = source.value,
        fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(originalModuleSpecifier, {
          filePath,
          options
        });
      fullySpecifiedModuleSpecifier && (source.value = fullySpecifiedModuleSpecifier);
    };
  return {
    name: "babel-plugin-fully-specified",
    visitor: {
      ImportDeclaration: importDeclarationVisitor,
      ExportNamedDeclaration: exportDeclarationVisitor,
      ExportAllDeclaration: exportDeclarationVisitor,
      Import: (path, state) => {
        const filePath = state.file.opts.filename;
        if (!filePath) return;
        const parent = path.parent;
        if (parent.type !== "CallExpression") return;
        const firstArgOfImportCall = parent.arguments[0];
        if (firstArgOfImportCall.type !== "StringLiteral") return;
        const originalModuleSpecifier = firstArgOfImportCall.value,
          fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(originalModuleSpecifier, {
            filePath,
            options
          });
        fullySpecifiedModuleSpecifier && (firstArgOfImportCall.value = fullySpecifiedModuleSpecifier);
      }
    }
  };
}
function getFullySpecifiedModuleSpecifier(originalModuleSpecifier, {
  filePath,
  options
}) {
  const fileExt = extname(filePath),
    fileDir = dirname(filePath),
    {
      includePackages
    } = options;
  let packageData = null;
  if (!isLocalFile(originalModuleSpecifier) && (includePackages.some(name => originalModuleSpecifier.startsWith(name)) && (packageData = getPackageData(originalModuleSpecifier, filePath)), !(packageData && packageData.isDeepImport))) return null;
  const isDirectory = isLocalDirectory(resolve(fileDir, originalModuleSpecifier)),
    currentModuleExtension = extname(originalModuleSpecifier),
    {
      tryExtensions,
      esExtensions,
      esExtensionDefault,
      ensureFileExists
    } = options,
    targetModule = evaluateTargetModule({
      moduleSpecifier: originalModuleSpecifier,
      filenameDirectory: fileDir,
      filenameExtension: fileExt,
      packageData,
      currentModuleExtension,
      isDirectory,
      tryExtensions,
      esExtensions,
      esExtensionDefault,
      ensureFileExists
    });
  return targetModule === !1 || currentModuleExtension === targetModule.extension ? null : targetModule.module;
}
function getPackageData(moduleSpecifier, filePath) {
  try {
    const modulePath = require.resolve(moduleSpecifier, {
        paths: filePath ? [filePath] : []
      }),
      parts = modulePath.split("/");
    let packageDir = "";
    for (let i = parts.length; i >= 0; i--) {
      const dir = dirname(parts.slice(0, i).join("/"));
      if (existsSync(`${dir}/package.json`)) {
        packageDir = dir;
        break;
      }
    }
    if (!packageDir) throw new Error("no package dir");
    const packageJson = JSON.parse(readFileSync(`${packageDir}/package.json`).toString());
    return {
      isDeepImport: !moduleSpecifier.endsWith(packageJson.name),
      modulePath
    };
  } catch {}
  return null;
}
function isLocalFile(moduleSpecifier) {
  return moduleSpecifier.startsWith(".") || moduleSpecifier.startsWith("/");
}
function isLocalDirectory(absoluteDirectory) {
  return existsSync(absoluteDirectory) && lstatSync(absoluteDirectory).isDirectory();
}
function evaluateTargetModule({
  moduleSpecifier,
  currentModuleExtension,
  packageData,
  isDirectory,
  filenameDirectory,
  filenameExtension,
  tryExtensions,
  esExtensions,
  esExtensionDefault,
  ensureFileExists
}) {
  if (packageData) return packageData.modulePath.endsWith("index.js") && !moduleSpecifier.endsWith("index.js") && (moduleSpecifier = `${moduleSpecifier}/index`), {
    module: moduleSpecifier + esExtensionDefault,
    extension: esExtensionDefault
  };
  if (currentModuleExtension && !esExtensions.includes(currentModuleExtension)) return !1;
  isDirectory && !existsSync(resolve(filenameDirectory, currentModuleExtension ? moduleSpecifier : moduleSpecifier + esExtensionDefault)) && (moduleSpecifier = `${moduleSpecifier}/index`);
  const targetFile = resolve(filenameDirectory, moduleSpecifier);
  if (ensureFileExists) {
    if (esExtensions.includes(filenameExtension) && existsSync(targetFile + filenameExtension)) return {
      module: moduleSpecifier + (ensureFileExists.forceExtension || filenameExtension),
      extension: filenameExtension
    };
    for (const extension of tryExtensions) if (existsSync(targetFile + extension)) return {
      module: moduleSpecifier + (ensureFileExists.forceExtension || extension),
      extension
    };
  } else return esExtensions.includes(filenameExtension) ? {
    module: moduleSpecifier + filenameExtension,
    extension: filenameExtension
  } : {
    module: moduleSpecifier + esExtensionDefault,
    extension: esExtensionDefault
  };
  return !1;
}
export { FullySpecified as default };
//# sourceMappingURL=index.mjs.map
