import { existsSync, readFileSync, lstatSync } from "node:fs";
import { resolve, extname, dirname } from "node:path";
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
var DEFAULT_OPTIONS = {
  ensureFileExists: !1,
  esExtensionDefault: ".js",
  tryExtensions: [
    ".js",
    ".mjs",
    ".cjs"
  ],
  esExtensions: [
    ".js",
    ".mjs",
    ".cjs"
  ],
  includePackages: []
};
function FullySpecified(api, rawOptions) {
  api.assertVersion(7);
  var options = _object_spread({}, DEFAULT_OPTIONS, rawOptions), importDeclarationVisitor = function(path, state) {
    var filePath = state.file.opts.filename;
    if (filePath) {
      var node = path.node;
      if (node.importKind !== "type") {
        var originalModuleSpecifier = node.source.value, fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(originalModuleSpecifier, {
          filePath,
          options
        });
        fullySpecifiedModuleSpecifier && (node.source.value = fullySpecifiedModuleSpecifier);
      }
    }
  }, exportDeclarationVisitor = function(path, state) {
    var filePath = state.file.opts.filename;
    if (filePath) {
      var node = path.node;
      if (node.exportKind !== "type") {
        var source = node.source;
        if (source) {
          var originalModuleSpecifier = source.value, fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(originalModuleSpecifier, {
            filePath,
            options
          });
          fullySpecifiedModuleSpecifier && (source.value = fullySpecifiedModuleSpecifier);
        }
      }
    }
  }, importVisitor = function(path, state) {
    var filePath = state.file.opts.filename;
    if (filePath) {
      var parent = path.parent;
      if (parent.type === "CallExpression") {
        var firstArgOfImportCall = parent.arguments[0];
        if (firstArgOfImportCall.type === "StringLiteral") {
          var originalModuleSpecifier = firstArgOfImportCall.value, fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(originalModuleSpecifier, {
            filePath,
            options
          });
          fullySpecifiedModuleSpecifier && (firstArgOfImportCall.value = fullySpecifiedModuleSpecifier);
        }
      }
    }
  };
  return {
    name: "babel-plugin-fully-specified",
    visitor: {
      ImportDeclaration: importDeclarationVisitor,
      ExportNamedDeclaration: exportDeclarationVisitor,
      ExportAllDeclaration: exportDeclarationVisitor,
      Import: importVisitor
    }
  };
}
function getFullySpecifiedModuleSpecifier(originalModuleSpecifier, param) {
  var filePath = param.filePath, options = param.options, fileExt = extname(filePath), fileDir = dirname(filePath), includePackages = options.includePackages, packageData = null;
  if (!isLocalFile(originalModuleSpecifier) && (includePackages.some(function(name) {
    return originalModuleSpecifier.startsWith(name);
  }) && (packageData = getPackageData(originalModuleSpecifier, filePath)), !(packageData && packageData.isDeepImport)))
    return null;
  var isDirectory = isLocalDirectory(resolve(fileDir, originalModuleSpecifier)), currentModuleExtension = extname(originalModuleSpecifier), tryExtensions = options.tryExtensions, esExtensions = options.esExtensions, esExtensionDefault = options.esExtensionDefault, ensureFileExists = options.ensureFileExists, targetModule = evaluateTargetModule({
    moduleSpecifier: originalModuleSpecifier,
    filenameDirectory: fileDir,
    filenameExtension: fileExt,
    packageData,
    currentModuleExtension,
    isDirectory,
    tryExtensions,
    esExtensions,
    esExtensionDefault,
    ensureFileExists
  });
  return targetModule === !1 || currentModuleExtension === targetModule.extension ? null : targetModule.module;
}
function getPackageData(moduleSpecifier, filePath) {
  try {
    for (var modulePath = require.resolve(moduleSpecifier, {
      paths: filePath ? [
        filePath
      ] : []
    }), parts = modulePath.split("/"), packageDir = "", i = parts.length; i >= 0; i--) {
      var dir = dirname(parts.slice(0, i).join("/"));
      if (existsSync("".concat(dir, "/package.json"))) {
        packageDir = dir;
        break;
      }
    }
    if (!packageDir)
      throw new Error("no package dir");
    var packageJson = JSON.parse(readFileSync("".concat(packageDir, "/package.json")).toString()), isDeepImport = !moduleSpecifier.endsWith(packageJson.name);
    return {
      isDeepImport,
      modulePath
    };
  } catch {
  }
  return null;
}
function isLocalFile(moduleSpecifier) {
  return moduleSpecifier.startsWith(".") || moduleSpecifier.startsWith("/");
}
function isLocalDirectory(absoluteDirectory) {
  return existsSync(absoluteDirectory) && lstatSync(absoluteDirectory).isDirectory();
}
function evaluateTargetModule(param) {
  var moduleSpecifier = param.moduleSpecifier, currentModuleExtension = param.currentModuleExtension, packageData = param.packageData, isDirectory = param.isDirectory, filenameDirectory = param.filenameDirectory, filenameExtension = param.filenameExtension, tryExtensions = param.tryExtensions, esExtensions = param.esExtensions, esExtensionDefault = param.esExtensionDefault, ensureFileExists = param.ensureFileExists;
  if (packageData)
    return packageData.modulePath.endsWith("index.js") && !moduleSpecifier.endsWith("index.js") && (moduleSpecifier = "".concat(moduleSpecifier, "/index")), {
      module: moduleSpecifier + esExtensionDefault,
      extension: esExtensionDefault
    };
  if (currentModuleExtension && !esExtensions.includes(currentModuleExtension))
    return !1;
  isDirectory && !existsSync(resolve(filenameDirectory, currentModuleExtension ? moduleSpecifier : moduleSpecifier + esExtensionDefault)) && (moduleSpecifier = "".concat(moduleSpecifier, "/index"));
  var targetFile = resolve(filenameDirectory, moduleSpecifier);
  if (ensureFileExists) {
    if (esExtensions.includes(filenameExtension) && existsSync(targetFile + filenameExtension))
      return {
        module: moduleSpecifier + (ensureFileExists.forceExtension || filenameExtension),
        extension: filenameExtension
      };
    var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _iterator = tryExtensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var extension = _step.value;
        if (existsSync(targetFile + extension))
          return {
            module: moduleSpecifier + (ensureFileExists.forceExtension || extension),
            extension
          };
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
  } else return esExtensions.includes(filenameExtension) ? {
    module: moduleSpecifier + filenameExtension,
    extension: filenameExtension
  } : {
    module: moduleSpecifier + esExtensionDefault,
    extension: esExtensionDefault
  };
  return !1;
}
export {
  FullySpecified as default
};
//# sourceMappingURL=index.js.map
