import React from "react";
import { isAndroid, isClient, isServer, isWeb, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { StyleObjectIdentifier, StyleObjectProperty, StyleObjectPseudo, stylePropsText, stylePropsTransform, tokenCategories, validPseudoKeys, validStyles } from "@tamagui/helpers";
import { getConfig, getFont } from "../config";
import "../constants/accessibilityDirectMap";
import "../constants/constants";
import { isDevTools } from "../constants/isDevTools";
import { getMediaImportanceIfMoreImportant, mediaState as globalMediaState, isMediaKey, mediaKeyMatch, mediaQueryConfig } from "../hooks/useMedia";
import { createMediaStyle } from "./createMediaStyle";
import { fixStyles } from "./expandStyles";
import { getGroupPropParts } from "./getGroupPropParts";
import { getStyleAtomic, getStylesAtomic, styleToCSS } from "./getStylesAtomic";
import "./insertStyleRule";
import { log } from "./log";
import { normalizeValueWithProperty } from "./normalizeValueWithProperty";
import { getPropMappedFontFamily, propMapper } from "./propMapper";
import { pseudoDescriptors, pseudoPriorities } from "./pseudoDescriptors";
import { skipProps } from "./skipProps";
import { transformsToString } from "./transformsToString";
import { isActivePlatform } from "./isActivePlatform";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var consoleGroupCollapsed = isWeb ? console.groupCollapsed : console.info, conf, PROP_SPLIT = "-";
function isValidStyleKey(key, staticConfig) {
  var _staticConfig_accept, validStyleProps = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  return validStyleProps[key] || ((_staticConfig_accept = staticConfig.accept) === null || _staticConfig_accept === void 0 ? void 0 : _staticConfig_accept[key]);
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug, skipThemeTokenResolution) {
  var _loop = function(keyOg2) {
    var _loop2 = function(i3) {
      var _parentStaticConfig_variants;
      if (expanded) {
        var _expanded_i = _sliced_to_array(expanded[i3], 2), k = _expanded_i[0], v = _expanded_i[1];
        key4 = k, val2 = v;
      }
      if (val2 == null || key4 in usedKeys) return "continue";
      if (isPseudo = key4 in validPseudoKeys, isMedia = !isPseudo && !isValidStyleKeyInit && isMediaKey(key4), isMediaOrPseudo1 = !!(isMedia || isPseudo), isVariant = variants && key4 in variants, inlineProps != null && inlineProps.has(key4) || process.env.IS_STATIC === "is_static" && (inlineWhenUnflattened != null && inlineWhenUnflattened.has(key4))) {
        var _props_key;
        viewProps[key4] = (_props_key = props[key4]) !== null && _props_key !== void 0 ? _props_key : val2;
      }
      var shouldPassThrough2 = styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo1 || (parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit]));
      if (shouldPassThrough2)
        return passDownProp(viewProps, key4, val2, isMediaOrPseudo1), process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed(" - passing down prop ".concat(key4)), log({
          val: val2,
          after: _object_spread({}, viewProps[key4])
        }), console.groupEnd()), "continue";
      if (isPseudo) {
        if (!val2) return "continue";
        var pseudoStyleObject = getSubStyle(styleState, key4, val2, styleProps.noClassNames), descriptor = pseudoDescriptors[key4], isEnter = key4 === "enterStyle", isExit = key4 === "exitStyle";
        if (!descriptor)
          return "continue";
        if (!shouldDoClasses || process.env.IS_STATIC === "is_static") {
          var _pseudos, _key;
          if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key4] || (_pseudos[_key] = {}), process.env.IS_STATIC === "is_static")
            return Object.assign(pseudos[key4], pseudoStyleObject), "continue";
        }
        if (shouldDoClasses && !isExit) {
          var pseudoStyles = getStyleAtomic(pseudoStyleObject, descriptor);
          process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed("pseudo (classes)", key4), log({
            pseudoStyleObject,
            pseudoStyles
          }), console.groupEnd());
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator2 = pseudoStyles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
              var psuedoStyle = _step2.value, fullKey = "".concat(psuedoStyle[StyleObjectProperty]).concat(PROP_SPLIT).concat(descriptor.name);
              fullKey in usedKeys || (addStyleToInsertRules(rulesToInsert, psuedoStyle), mergeClassName(transforms, classNames, fullKey, psuedoStyle[StyleObjectIdentifier], isMediaOrPseudo1, !0));
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        }
        if (!shouldDoClasses || isExit || isEnter) {
          var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled = componentState[descriptorKey] === !1;
          isExit && (isDisabled = !styleProps.isExiting), isEnter && componentState.unmounted === !1 && (isDisabled = !0), process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed("pseudo", key4, {
            isDisabled
          }), log({
            pseudoStyleObject,
            isDisabled,
            descriptor,
            componentState
          }), console.groupEnd());
          var importance = descriptor.priority;
          for (var pkey in pseudoStyleObject) {
            var val12 = pseudoStyleObject[pkey];
            if (isDisabled)
              applyDefaultStyle(pkey, styleState);
            else {
              var curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
              if (shouldMerge) {
                var _pseudos1, _key1;
                pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key4] || (_pseudos1[_key1] = {}), pseudos[key4][pkey] = val12, mergeStyle(styleState, pkey, val12);
              }
              process.env.NODE_ENV === "development" && debug === "verbose" && log("    subKey", pkey, shouldMerge, {
                importance,
                curImportance,
                pkey,
                val: val12
              });
            }
          }
          if (!isDisabled)
            for (var key12 in val2) {
              var k1 = shorthands[key12] || key12;
              usedKeys[k1] = Math.max(importance, usedKeys[k1] || 0);
            }
        }
        return "continue";
      }
      if (isMedia) {
        if (!val2) return "continue";
        var hasSpace = val2.space, mediaKeyShort = key4.slice(1);
        if (hasMedia || (hasMedia = !0), (hasSpace || !shouldDoClasses || styleProps.willBeAnimated) && ((typeof hasMedia > "u" ? "undefined" : _type_of(hasMedia)) !== "object" && (hasMedia = {}), hasMedia[mediaKeyShort] = !0), isMedia === "platform" && !isActivePlatform(key4))
          return "continue";
        if (process.env.NODE_ENV === "development" && debug === "verbose" && log("  \u{1F4FA} ".concat(key4), {
          key: key4,
          val: val2,
          props,
          shouldDoClasses,
          acceptsClassName,
          componentState,
          mediaState
        }), shouldDoClasses) {
          var mediaStyle = getSubStyle(styleState, key4, val2, !1);
          if (hasSpace && (delete mediaStyle.space, mediaState[mediaKeyShort])) {
            var importance1 = getMediaImportanceIfMoreImportant(mediaKeyShort, "space", usedKeys, !0);
            importance1 && (space = val2.space, usedKeys.space = importance1, process.env.NODE_ENV === "development" && debug === "verbose" && log("Found more important space for current media ".concat(mediaKeyShort, ": ").concat(val2, " (importance: ").concat(importance1, ")")));
          }
          var mediaStyles = getStylesAtomic(mediaStyle), priority = mediaStylesSeen;
          mediaStylesSeen += 1;
          var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = mediaStyles[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = !0) {
              var style3 = _step12.value, property = style3[0];
              if (!(property[0] === "$" && property.startsWith("$platform") && !isActivePlatform(property))) {
                var out = createMediaStyle(style3, mediaKeyShort, mediaQueryConfig, isMedia, !1, priority);
                process.env.NODE_ENV === "development" && debug === "verbose" && log("\u{1F4FA} media style:", out);
                var fullKey1 = "".concat(style3[StyleObjectProperty]).concat(PROP_SPLIT).concat(mediaKeyShort).concat(style3[StyleObjectPseudo] || "");
                fullKey1 in usedKeys || (addStyleToInsertRules(rulesToInsert, out), mergeClassName(transforms, classNames, fullKey1, out[StyleObjectIdentifier], !0, !0));
              }
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator12.return != null && _iterator12.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        } else {
          var mergeMediaStyle = function(key5, val3) {
            var _styleState4;
            (_styleState4 = styleState).style || (_styleState4.style = {});
            var didMerge = mergeMediaByImportance(styleState, mediaKeyShort, key5, val3, usedKeys, mediaState[mediaKeyShort], importanceBump, debug);
            didMerge && key5 === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
          }, isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
          if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
            if (!mediaState[mediaKeyShort])
              return process.env.NODE_ENV === "development" && debug === "verbose" && log("  \u{1F4FA} \u274C DISABLED ".concat(mediaKeyShort)), "continue";
            process.env.NODE_ENV === "development" && debug === "verbose" && log("  \u{1F4FA} \u2705 ENABLED ".concat(mediaKeyShort));
          }
          var mediaStyle1 = getSubStyle(styleState, key4, val2, !0), importanceBump = 0;
          if (isThemeMedia) {
            dynamicThemeAccess = !0;
            var mediaThemeName = mediaKeyShort.slice(6);
            if (!(themeName === mediaThemeName || themeName.startsWith(mediaThemeName)))
              return "continue";
          } else if (isGroupMedia) {
            var _componentState_group, groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupContext = context == null ? void 0 : context.groups.state[groupName];
            if (!groupContext)
              return process.env.NODE_ENV === "development" && debug && log("No parent with group prop, skipping styles: ".concat(groupName)), "continue";
            var groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
            if (groupMediaKey) {
              mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
              var mediaState1 = componentGroupState == null ? void 0 : componentGroupState.media, isActive = mediaState1 == null ? void 0 : mediaState1[groupMediaKey];
              if (!mediaState1 && groupContext.layout && (isActive = mediaKeyMatch(groupMediaKey, groupContext.layout)), process.env.NODE_ENV === "development" && debug === "verbose" && log(" \u{1F3D8}\uFE0F GROUP media ".concat(groupMediaKey, " active? ").concat(isActive)), !isActive) {
                for (var pkey1 in mediaStyle1)
                  applyDefaultStyle(pkey1, styleState);
                return "continue";
              }
              importanceBump = 2;
            }
            if (groupPseudoKey) {
              pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
              var componentGroupPseudoState = (componentGroupState || // fallback to context initially
              context.groups.state[groupName]).pseudo, isActive1 = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey], priority1 = pseudoPriorities[groupPseudoKey];
              if (process.env.NODE_ENV === "development" && debug === "verbose" && log(" \u{1F3D8}\uFE0F GROUP pseudo ".concat(groupMediaKey, " active? ").concat(isActive1, ", priority ").concat(priority1)), !isActive1) {
                for (var pkey2 in mediaStyle1)
                  applyDefaultStyle(pkey2, styleState);
                return "continue";
              }
              importanceBump = priority1;
            }
          }
          for (var subKey in mediaStyle1) {
            if (subKey === "space") {
              space = valInit.space;
              continue;
            }
            if (subKey[0] === "$") {
              if (!isActivePlatform(subKey))
                continue;
              for (var subSubKey in mediaStyle1[subKey])
                mergeMediaStyle(subSubKey, mediaStyle1[subKey][subSubKey]);
            } else
              mergeMediaStyle(subKey, mediaStyle1[subKey]);
          }
        }
        return "continue";
      }
      if (key4 === "pointerEvents")
        return viewProps[key4] = val2, "continue";
      if (
        // is HOC we can just pass through the styles as props
        // this fixes issues where style prop got merged with wrong priority
        !isHOC && (isValidStyleKey(key4, staticConfig) || isAndroid && key4 === "elevation")
      )
        return mergeStyle(styleState, key4, val2), "continue";
      isVariant || (viewProps[key4] = val2);
    }, keyInit = keyOg2, valInit = props[keyInit];
    if (accept) {
      var accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && (typeof valInit > "u" ? "undefined" : _type_of(valInit)) === "object")
        return viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps.noClassNames), "continue";
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd(), disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className" || keyInit in usedKeys) return "continue";
    if (keyInit in skipProps && !noSkip && !isHOC) {
      if (keyInit === "group" && 0)
        var identifier2, containerType, containerCSS;
      return "continue";
    }
    var valInitType = typeof valInit > "u" ? "undefined" : _type_of(valInit), isValidStyleKeyInit = isValidStyleKey(keyInit, staticConfig);
    if (0 && isValidStyleKeyInit && valInitType === "string" && valInit[0] === "_") {
      var isValidClassName, isMediaOrPseudo;
      if ((isValidClassName || isMediaOrPseudo) && !shouldDoClasses)
        var _styleState3;
    }
    if (!isValidStyleKeyInit) {
      if (!isAndroid && keyInit === "elevationAndroid")
        return "continue";
      if (keyInit === "userSelect")
        keyInit = "selectable", valInit = valInit !== "none";
      else if (keyInit.startsWith("data-"))
        return "continue";
    }
    if (keyInit === "dataSet") {
      for (var keyInit1 in valInit)
        viewProps["data-".concat(hyphenate(keyInit1))] = valInit[keyInit1];
      return "continue";
    }
    if (0 && !noExpand)
      var didUseKeyInit;
    var isShorthand = keyInit in shorthands, isVariant = !isValidStyleKeyInit && variants && keyInit in variants, isStyleLikeKey = isShorthand || isValidStyleKeyInit || isVariant, isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && isMediaKey(keyInit), isMediaOrPseudo1 = !!(isMedia || isPseudo);
    if (isMediaOrPseudo1 && keyInit.startsWith("$group-")) {
      var name2 = keyInit.split("-")[1];
      context != null && context.groups.subscribe && !(context != null && context.groups.state[name2]) && (keyInit = keyInit.replace("$group-", "$group-true-"));
    }
    var isStyleProp = isValidStyleKeyInit || isMediaOrPseudo1 || isVariant && !noExpand || isShorthand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web"))
      return "continue";
    var shouldPassProp = !isStyleProp || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentVariants == null ? void 0 : parentVariants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isShorthand || isValidStyleKeyInit || isMediaOrPseudo1 || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupEnd(), console.groupEnd(), consoleGroupCollapsed("  \u{1F511} ".concat(keyOg2).concat(keyInit !== keyOg2 ? " (shorthand for ".concat(keyInit, ")") : "", " ").concat(shouldPassThrough ? "(pass)" : "")), log({
      isVariant,
      valInit,
      shouldPassProp
    }), isClient && log({
      variants,
      variant: variants == null ? void 0 : variants[keyInit],
      isVariant,
      isHOCShouldPassThrough,
      curProps: _object_spread({}, styleState.curProps),
      parentStaticConfig
    })), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo1), !isVariant) || !noSkip && keyInit in skipProps)
      return process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd(), "continue";
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
    var avoidPropMap = isMediaOrPseudo1 || !isVariant && !isValidStyleKeyInit, expanded = avoidPropMap ? null : propMapper(keyInit, valInit, styleState);
    if (!avoidPropMap) {
      if (!expanded) return "continue";
      var next = getPropMappedFontFamily(expanded);
      next && (styleState.fontFamily = next);
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      consoleGroupCollapsed("  \u{1F4A0} expanded", keyInit, valInit);
      try {
        !isServer && isDevTools && (log({
          expanded,
          styleProps,
          componentState,
          isVariant,
          variant: variants == null ? void 0 : variants[keyInit],
          shouldPassProp,
          isHOCShouldPassThrough,
          usedKeys: _object_spread({}, usedKeys),
          curProps: _object_spread({}, styleState.curProps)
        }), log("expanded", expanded, `
usedKeys`, _object_spread({}, usedKeys), `
current`, _object_spread({}, styleState.style)));
      } catch {
      }
      console.groupEnd();
    }
    for (var key4 = keyInit, val2 = valInit, max = expanded ? expanded.length : 1, i2 = 0; i2 < max; i2++) _loop2(i2);
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      try {
        log(" \u2714\uFE0F expand complete", keyInit), log("style", _object_spread({}, styleState.style)), log("transforms", _object_spread({}, transforms)), log("viewProps", _object_spread({}, viewProps));
      } catch {
      }
      console.groupEnd();
    }
  };
  conf = conf || getConfig(), isWeb && styleProps.isAnimated && conf.animations.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  var shorthands = conf.shorthands, isHOC = staticConfig.isHOC, isText = staticConfig.isText, isInput = staticConfig.isInput, variants = staticConfig.variants, isReactNative = staticConfig.isReactNative, inlineProps = staticConfig.inlineProps, inlineWhenUnflattened = staticConfig.inlineWhenUnflattened, parentStaticConfig = staticConfig.parentStaticConfig, acceptsClassName = staticConfig.acceptsClassName, viewProps = {}, mediaState = styleProps.mediaState || globalMediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && isWeb && !styleProps.noClassNames, rulesToInsert = void 0, classNames = {}, transforms = {}, pseudos = null, space = props.space, hasMedia = !1, dynamicThemeAccess, pseudoGroups, mediaGroups, className = props.className || "", mediaStylesSeen = 0, curPropsState, styleState = {
    // this should go away, right now we're doing really crazy cumulative props,
    // as variants are resolved basically we go back and merge the results onto
    // the curProps, so that each following variant function recieves the current
    // "styles" with variants expanded. powerful, but i think too fancy
    // there's some part of the ui kit that depends on it we'd have to find and fix
    get curProps() {
      return curPropsState || (curPropsState = {}), curPropsState;
    },
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys,
    viewProps,
    context,
    debug,
    skipThemeTokenResolution
  };
  process.env.NODE_ENV === "development" && debug && debug !== "profile" && isClient && (consoleGroupCollapsed("getSplitStyles (collapsed)"), log({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    rulesToInsert,
    componentState,
    styleState,
    theme: _object_spread({}, theme)
  }), console.groupEnd());
  var asChild = props.asChild, accept = staticConfig.accept, noSkip = styleProps.noSkip, disableExpandShorthands = styleProps.disableExpandShorthands, noExpand = styleProps.noExpand, webContainerType = conf.settings.webContainerType, parentVariants = parentStaticConfig == null ? void 0 : parentStaticConfig.variants;
  for (var keyOg in props) _loop(keyOg);
  var avoidNormalize = styleProps.noNormalize === !1;
  if (!avoidNormalize) {
    if (styleState.style && (fixStyles(styleState.style), isWeb && !isReactNative && styleToCSS(styleState.style)), styleState.flatTransforms) {
      var _styleState;
      (_styleState = styleState).style || (_styleState.style = {}), Object.entries(styleState.flatTransforms).sort(function(param, param1) {
        var _param = _sliced_to_array(param, 1), a = _param[0], _param1 = _sliced_to_array(param1, 1), b = _param1[0];
        return a.localeCompare(b);
      }).forEach(function(param) {
        var _param = _sliced_to_array(param, 2), key4 = _param[0], val2 = _param[1];
        mergeTransform(styleState.style, key4, val2, !0);
      });
    }
    if (parentSplitStyles) {
      if (0 && shouldDoClasses)
        for (var key in parentSplitStyles.classNames)
          var val;
      if (!shouldDoClasses)
        for (var key1 in parentSplitStyles.style) {
          var _styleState1;
          key1 in classNames || styleState.style && key1 in styleState.style || ((_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key1] = parentSplitStyles.style[key1]);
        }
    }
  }
  if (0)
    var _styleState_style, shouldStringifyTransforms;
  if (0) {
    if (styleState.style && shouldDoClasses) {
      var retainedStyles, shouldRetain;
      if (!styleState.style.$$css) {
        var atomic, _iteratorNormalCompletion, _didIteratorError, _iteratorError;
        try {
          for (var _iterator, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0)
            var atomicStyle, _props_animateOnly, _atomicStyle, key2, value, identifier, isAnimatedAndAnimateOnly, nonAnimatedAnimateOnly;
        } catch (err) {
        } finally {
          try {
          } finally {
          }
        }
      }
      if (transforms)
        for (var namespace in transforms) {
          var _transforms_namespace, hash, val1, identifier1;
          if (isClient && !insertedTransforms[identifier1])
            var rule;
        }
    }
    if (isReactNative) {
      if (viewProps.tabIndex === 0)
        var _viewProps, _accessible;
    } else if (viewProps.tabIndex == null)
      var _viewProps_focusable, isFocusable, role;
  }
  var styleProp = props.style;
  if (styleProp)
    if (isHOC)
      viewProps.style = normalizeStyle(styleProp);
    else
      for (var isArray = Array.isArray(styleProp), len = isArray ? styleProp.length : 1, i = 0; i < len; i++) {
        var style = isArray ? styleProp[i] : styleProp;
        if (style)
          if (style.$$css)
            Object.assign(styleState.classNames, style);
          else {
            var _styleState2;
            (_styleState2 = styleState).style || (_styleState2.style = {}), Object.assign(styleState.style, normalizeStyle(style));
          }
      }
  var style1 = styleState.style;
  if (style1 != null && style1.fontFamily) {
    var _getFont, faceInfo = (_getFont = getFont(style1.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style1.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style1.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style1.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style1.fontWeight, delete style1.fontStyle);
    }
    process.env.NODE_ENV === "development" && debug && debug !== "profile" && log("Found fontFamily native: ".concat(style1.fontFamily), faceInfo);
  }
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!asChildExceptStyleLike) {
    var style2 = styleState.style;
    if (0) {
      var _staticConfig_defaultProps, fontFamily, fontFamilyClassName, groupClassName, componentNameFinal, componentClassName, classList, finalClassName;
      if (!styleProps.noMergeStyle) {
        if (!(styleProps.isAnimated && !conf.animations.supportsCSSVars && isReactNative)) {
          if (isReactNative) {
            var cnStyles, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1;
            try {
              for (var _iterator1, _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0)
                var name;
            } catch (err) {
            } finally {
              try {
              } finally {
              }
            }
          }
        }
      }
    } else
      style2 && !styleProps.noMergeStyle && (viewProps.style = style2);
  }
  if (process.env.NODE_ENV === "development" && debug === "verbose" && isDevTools) {
    consoleGroupCollapsed("\u{1F539} getSplitStyles ===>");
    try {
      var logs = _object_spread_props(_object_spread({}, result), {
        className,
        componentState,
        transforms,
        viewProps,
        rulesToInsert,
        parentSplitStyles
      });
      for (var key3 in logs)
        log(key3, logs[key3]);
    } catch {
    }
    console.groupEnd();
  }
  return result;
};
function mergeClassName(transforms, classNames, key, val) {
  var isMediaOrPseudo = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, isInsertingNow = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
  if (0 && !isInsertingNow && val[0] === "_" && val.startsWith("_transform-"))
    var _transforms, _ns, ns, transform;
}
function mergeStyle(styleState, key, val) {
  var disableNormalize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, classNames = styleState.classNames, viewProps = styleState.viewProps, usedKeys = styleState.usedKeys, styleProps = styleState.styleProps, staticConfig = styleState.staticConfig;
  if (isWeb && (val == null ? void 0 : val[0]) === "_") {
    var _usedKeys, _key;
    classNames[key] = val, (_usedKeys = usedKeys)[_key = key] || (_usedKeys[_key] = 1);
  } else if (key in stylePropsTransform) {
    var _styleState;
    (_styleState = styleState).flatTransforms || (_styleState.flatTransforms = {}), styleState.flatTransforms[key] = val;
  } else {
    var shouldNormalize = isWeb && !disableNormalize && !styleProps.noNormalize, out = shouldNormalize ? normalizeValueWithProperty(val, key) : val;
    if (
      // accept is for props not styles
      staticConfig.accept && key in staticConfig.accept
    )
      viewProps[key] = out;
    else {
      var _styleState1;
      (_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key] = out;
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var staticConfig = styleState.staticConfig, props = styleState.props, conf2 = styleState.conf, styleProps = styleState.styleProps, styleOut = {};
  for (var key in styleIn) {
    var val = styleIn[key];
    key = conf2.shorthands[key] || key;
    var expanded = propMapper(key, val, styleState, _object_spread({}, props, props[subKey]));
    if (!(!expanded || !staticConfig.isHOC && key in skipProps && !styleProps.noSkip)) {
      var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
      try {
        for (var _iterator = expanded[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
          var _step_value = _sliced_to_array(_step.value, 2), skey = _step_value[0], sval = _step_value[1];
          !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : normalizeValueWithProperty(sval, key);
        }
      } catch (err) {
        _didIteratorError = !0, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError)
            throw _iteratorError;
        }
      }
    }
  }
  return styleProps.noNormalize || fixStyles(styleOut), styleOut;
}, useInsertEffectCompat = isWeb ? React.useInsertionEffect || useIsomorphicLayoutEffect : function() {
}, useSplitStyles = function(a, b, c, d, e, f, g, h, i, j) {
  conf = conf || getConfig();
  var res = getSplitStyles(a, b, c, d, e, f, g, h, i, j);
  return res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  if (0)
    var identifier;
}
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = _object_spread_props(_object_spread({}, Object.fromEntries(Object.entries(tokenCategories.color).map(function(param) {
  var _param = _sliced_to_array(param, 2), k = _param[0], v = _param[1];
  return [
    k,
    defaultColor
  ];
}))), {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}), lowercaseHyphenate = function(match) {
  return "-".concat(match.toLowerCase());
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"](_define_property({}, mapTransformKeys[key] || key, val)));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (shouldMergeObject) {
    var next = _object_spread({}, viewProps[key], val);
    delete viewProps[key], viewProps[key] = next;
  } else
    viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump, debugProp) {
  var importance = getMediaImportanceIfMoreImportant(mediaKey, key, importancesUsed, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), process.env.NODE_ENV === "development" && debugProp === "verbose" && log("mergeMediaByImportance ".concat(key, " importance existing ").concat(importancesUsed[key], " next ").concat(importance)), importance === null)
    return !1;
  if (importancesUsed[key] = importance, key in pseudoDescriptors) {
    var descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name, isDisabled = styleState.componentState[descriptorKey] === !1;
    if (isDisabled)
      return !1;
    for (var subKey in value)
      mergeStyle(styleState, subKey, value[subKey]);
  } else
    mergeStyle(styleState, key, value);
  return !0;
}
function normalizeStyle(style) {
  var out = {};
  for (var key in style) {
    var val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty(val, key);
  }
  return isWeb && Array.isArray(out.transform) && (out.transform = transformsToString(out.transform)), fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  var defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues);
}
export {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
};
//# sourceMappingURL=getSplitStyles.js.map
